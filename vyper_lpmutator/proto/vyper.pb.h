// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vyper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vyper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vyper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vyper_2eproto;
namespace vyper {
class ArgDef;
class ArgDefDefaultTypeInternal;
extern ArgDefDefaultTypeInternal _ArgDef_default_instance_;
class Assignment;
class AssignmentDefaultTypeInternal;
extern AssignmentDefaultTypeInternal _Assignment_default_instance_;
class BuiltinCall;
class BuiltinCallDefaultTypeInternal;
extern BuiltinCallDefaultTypeInternal _BuiltinCall_default_instance_;
class CodeBlock;
class CodeBlockDefaultTypeInternal;
extern CodeBlockDefaultTypeInternal _CodeBlock_default_instance_;
class ConcatCall;
class ConcatCallDefaultTypeInternal;
extern ConcatCallDefaultTypeInternal _ConcatCall_default_instance_;
class ConvertCall;
class ConvertCallDefaultTypeInternal;
extern ConvertCallDefaultTypeInternal _ConvertCall_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class FunctionDef;
class FunctionDefDefaultTypeInternal;
extern FunctionDefDefaultTypeInternal _FunctionDef_default_instance_;
class IfStatement;
class IfStatementDefaultTypeInternal;
extern IfStatementDefaultTypeInternal _IfStatement_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Uint256;
class Uint256DefaultTypeInternal;
extern Uint256DefaultTypeInternal _Uint256_default_instance_;
class ValOrOp;
class ValOrOpDefaultTypeInternal;
extern ValOrOpDefaultTypeInternal _ValOrOp_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class VyperContract;
class VyperContractDefaultTypeInternal;
extern VyperContractDefaultTypeInternal _VyperContract_default_instance_;
}  // namespace vyper
PROTOBUF_NAMESPACE_OPEN
template<> ::vyper::ArgDef* Arena::CreateMaybeMessage<::vyper::ArgDef>(Arena*);
template<> ::vyper::Assignment* Arena::CreateMaybeMessage<::vyper::Assignment>(Arena*);
template<> ::vyper::BuiltinCall* Arena::CreateMaybeMessage<::vyper::BuiltinCall>(Arena*);
template<> ::vyper::CodeBlock* Arena::CreateMaybeMessage<::vyper::CodeBlock>(Arena*);
template<> ::vyper::ConcatCall* Arena::CreateMaybeMessage<::vyper::ConcatCall>(Arena*);
template<> ::vyper::ConvertCall* Arena::CreateMaybeMessage<::vyper::ConvertCall>(Arena*);
template<> ::vyper::FunctionCall* Arena::CreateMaybeMessage<::vyper::FunctionCall>(Arena*);
template<> ::vyper::FunctionDef* Arena::CreateMaybeMessage<::vyper::FunctionDef>(Arena*);
template<> ::vyper::IfStatement* Arena::CreateMaybeMessage<::vyper::IfStatement>(Arena*);
template<> ::vyper::Operation* Arena::CreateMaybeMessage<::vyper::Operation>(Arena*);
template<> ::vyper::Operator* Arena::CreateMaybeMessage<::vyper::Operator>(Arena*);
template<> ::vyper::Statement* Arena::CreateMaybeMessage<::vyper::Statement>(Arena*);
template<> ::vyper::Type* Arena::CreateMaybeMessage<::vyper::Type>(Arena*);
template<> ::vyper::Uint256* Arena::CreateMaybeMessage<::vyper::Uint256>(Arena*);
template<> ::vyper::ValOrOp* Arena::CreateMaybeMessage<::vyper::ValOrOp>(Arena*);
template<> ::vyper::Value* Arena::CreateMaybeMessage<::vyper::Value>(Arena*);
template<> ::vyper::VyperContract* Arena::CreateMaybeMessage<::vyper::VyperContract>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vyper {

enum Operator_OPERATOR : int {
  Operator_OPERATOR_PLUS = 0,
  Operator_OPERATOR_MINUS = 1,
  Operator_OPERATOR_TIMES = 2,
  Operator_OPERATOR_MOD = 3,
  Operator_OPERATOR_Operator_OPERATOR_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Operator_OPERATOR_Operator_OPERATOR_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Operator_OPERATOR_IsValid(int value);
constexpr Operator_OPERATOR Operator_OPERATOR_OPERATOR_MIN = Operator_OPERATOR_PLUS;
constexpr Operator_OPERATOR Operator_OPERATOR_OPERATOR_MAX = Operator_OPERATOR_MOD;
constexpr int Operator_OPERATOR_OPERATOR_ARRAYSIZE = Operator_OPERATOR_OPERATOR_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operator_OPERATOR_descriptor();
template<typename T>
inline const std::string& Operator_OPERATOR_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Operator_OPERATOR>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Operator_OPERATOR_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Operator_OPERATOR_descriptor(), enum_t_value);
}
inline bool Operator_OPERATOR_Parse(
    const std::string& name, Operator_OPERATOR* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Operator_OPERATOR>(
    Operator_OPERATOR_descriptor(), name, value);
}
enum TYPE_ENUM : int {
  uint256 = 0,
  int256 = 1,
  int64 = 2,
  bytes32 = 3,
  String = 4,
  TYPE_ENUM_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TYPE_ENUM_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TYPE_ENUM_IsValid(int value);
constexpr TYPE_ENUM TYPE_ENUM_MIN = uint256;
constexpr TYPE_ENUM TYPE_ENUM_MAX = String;
constexpr int TYPE_ENUM_ARRAYSIZE = TYPE_ENUM_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TYPE_ENUM_descriptor();
template<typename T>
inline const std::string& TYPE_ENUM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TYPE_ENUM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TYPE_ENUM_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TYPE_ENUM_descriptor(), enum_t_value);
}
inline bool TYPE_ENUM_Parse(
    const std::string& name, TYPE_ENUM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TYPE_ENUM>(
    TYPE_ENUM_descriptor(), name, value);
}
// ===================================================================

class Statement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {};
  virtual ~Statement();

  Statement(const Statement& from);
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Statement& default_instance();

  enum StatementCase {
    kAssignment = 1,
    kIfStatement = 2,
    kFunctionCall = 3,
    kBuiltinCall = 4,
    STATEMENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }
  inline void Swap(Statement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(nullptr);
  }

  Statement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Statement";
  }
  protected:
  explicit Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentFieldNumber = 1,
    kIfStatementFieldNumber = 2,
    kFunctionCallFieldNumber = 3,
    kBuiltinCallFieldNumber = 4,
  };
  // .vyper.Assignment assignment = 1;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::vyper::Assignment& assignment() const;
  ::vyper::Assignment* release_assignment();
  ::vyper::Assignment* mutable_assignment();
  void set_allocated_assignment(::vyper::Assignment* assignment);
  private:
  const ::vyper::Assignment& _internal_assignment() const;
  ::vyper::Assignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::vyper::Assignment* assignment);
  ::vyper::Assignment* unsafe_arena_release_assignment();

  // .vyper.IfStatement if_statement = 2;
  bool has_if_statement() const;
  private:
  bool _internal_has_if_statement() const;
  public:
  void clear_if_statement();
  const ::vyper::IfStatement& if_statement() const;
  ::vyper::IfStatement* release_if_statement();
  ::vyper::IfStatement* mutable_if_statement();
  void set_allocated_if_statement(::vyper::IfStatement* if_statement);
  private:
  const ::vyper::IfStatement& _internal_if_statement() const;
  ::vyper::IfStatement* _internal_mutable_if_statement();
  public:
  void unsafe_arena_set_allocated_if_statement(
      ::vyper::IfStatement* if_statement);
  ::vyper::IfStatement* unsafe_arena_release_if_statement();

  // .vyper.FunctionCall function_call = 3;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;
  public:
  void clear_function_call();
  const ::vyper::FunctionCall& function_call() const;
  ::vyper::FunctionCall* release_function_call();
  ::vyper::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::vyper::FunctionCall* function_call);
  private:
  const ::vyper::FunctionCall& _internal_function_call() const;
  ::vyper::FunctionCall* _internal_mutable_function_call();
  public:
  void unsafe_arena_set_allocated_function_call(
      ::vyper::FunctionCall* function_call);
  ::vyper::FunctionCall* unsafe_arena_release_function_call();

  // .vyper.BuiltinCall builtin_call = 4;
  bool has_builtin_call() const;
  private:
  bool _internal_has_builtin_call() const;
  public:
  void clear_builtin_call();
  const ::vyper::BuiltinCall& builtin_call() const;
  ::vyper::BuiltinCall* release_builtin_call();
  ::vyper::BuiltinCall* mutable_builtin_call();
  void set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call);
  private:
  const ::vyper::BuiltinCall& _internal_builtin_call() const;
  ::vyper::BuiltinCall* _internal_mutable_builtin_call();
  public:
  void unsafe_arena_set_allocated_builtin_call(
      ::vyper::BuiltinCall* builtin_call);
  ::vyper::BuiltinCall* unsafe_arena_release_builtin_call();

  void clear_statement();
  StatementCase statement_case() const;
  // @@protoc_insertion_point(class_scope:vyper.Statement)
 private:
  class _Internal;
  void set_has_assignment();
  void set_has_if_statement();
  void set_has_function_call();
  void set_has_builtin_call();

  inline bool has_statement() const;
  inline void clear_has_statement();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StatementUnion {
    StatementUnion() {}
    ::vyper::Assignment* assignment_;
    ::vyper::IfStatement* if_statement_;
    ::vyper::FunctionCall* function_call_;
    ::vyper::BuiltinCall* builtin_call_;
  } statement_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Uint256 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Uint256) */ {
 public:
  inline Uint256() : Uint256(nullptr) {};
  virtual ~Uint256();

  Uint256(const Uint256& from);
  Uint256(Uint256&& from) noexcept
    : Uint256() {
    *this = ::std::move(from);
  }

  inline Uint256& operator=(const Uint256& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint256& operator=(Uint256&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Uint256& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint256* internal_default_instance() {
    return reinterpret_cast<const Uint256*>(
               &_Uint256_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Uint256& a, Uint256& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint256* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint256* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Uint256* New() const final {
    return CreateMaybeMessage<Uint256>(nullptr);
  }

  Uint256* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Uint256>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Uint256& from);
  void MergeFrom(const Uint256& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint256* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Uint256";
  }
  protected:
  explicit Uint256(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHbFieldNumber = 1,
    kLbFieldNumber = 2,
  };
  // uint64 hb = 1;
  void clear_hb();
  ::PROTOBUF_NAMESPACE_ID::uint64 hb() const;
  void set_hb(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_hb() const;
  void _internal_set_hb(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 lb = 2;
  void clear_lb();
  ::PROTOBUF_NAMESPACE_ID::uint64 lb() const;
  void set_lb(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lb() const;
  void _internal_set_lb(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vyper.Uint256)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 hb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lb_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Value) */ {
 public:
  inline Value() : Value(nullptr) {};
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum ValueCase {
    kStrLiteral = 1,
    kVarName = 2,
    kNum = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrLiteralFieldNumber = 1,
    kVarNameFieldNumber = 2,
    kNumFieldNumber = 3,
  };
  // string str_literal = 1;
  private:
  bool _internal_has_str_literal() const;
  public:
  void clear_str_literal();
  const std::string& str_literal() const;
  void set_str_literal(const std::string& value);
  void set_str_literal(std::string&& value);
  void set_str_literal(const char* value);
  void set_str_literal(const char* value, size_t size);
  std::string* mutable_str_literal();
  std::string* release_str_literal();
  void set_allocated_str_literal(std::string* str_literal);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_str_literal();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_str_literal(
      std::string* str_literal);
  private:
  const std::string& _internal_str_literal() const;
  void _internal_set_str_literal(const std::string& value);
  std::string* _internal_mutable_str_literal();
  public:

  // string var_name = 2;
  private:
  bool _internal_has_var_name() const;
  public:
  void clear_var_name();
  const std::string& var_name() const;
  void set_var_name(const std::string& value);
  void set_var_name(std::string&& value);
  void set_var_name(const char* value);
  void set_var_name(const char* value, size_t size);
  std::string* mutable_var_name();
  std::string* release_var_name();
  void set_allocated_var_name(std::string* var_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_var_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_var_name(
      std::string* var_name);
  private:
  const std::string& _internal_var_name() const;
  void _internal_set_var_name(const std::string& value);
  std::string* _internal_mutable_var_name();
  public:

  // .vyper.Uint256 num = 3;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  const ::vyper::Uint256& num() const;
  ::vyper::Uint256* release_num();
  ::vyper::Uint256* mutable_num();
  void set_allocated_num(::vyper::Uint256* num);
  private:
  const ::vyper::Uint256& _internal_num() const;
  ::vyper::Uint256* _internal_mutable_num();
  public:
  void unsafe_arena_set_allocated_num(
      ::vyper::Uint256* num);
  ::vyper::Uint256* unsafe_arena_release_num();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:vyper.Value)
 private:
  class _Internal;
  void set_has_str_literal();
  void set_has_var_name();
  void set_has_num();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_literal_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    ::vyper::Uint256* num_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Operator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Operator) */ {
 public:
  inline Operator() : Operator(nullptr) {};
  virtual ~Operator();

  Operator(const Operator& from);
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }
  inline void Swap(Operator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(nullptr);
  }

  Operator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Operator";
  }
  protected:
  explicit Operator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Operator_OPERATOR OPERATOR;
  static constexpr OPERATOR PLUS =
    Operator_OPERATOR_PLUS;
  static constexpr OPERATOR MINUS =
    Operator_OPERATOR_MINUS;
  static constexpr OPERATOR TIMES =
    Operator_OPERATOR_TIMES;
  static constexpr OPERATOR MOD =
    Operator_OPERATOR_MOD;
  static inline bool OPERATOR_IsValid(int value) {
    return Operator_OPERATOR_IsValid(value);
  }
  static constexpr OPERATOR OPERATOR_MIN =
    Operator_OPERATOR_OPERATOR_MIN;
  static constexpr OPERATOR OPERATOR_MAX =
    Operator_OPERATOR_OPERATOR_MAX;
  static constexpr int OPERATOR_ARRAYSIZE =
    Operator_OPERATOR_OPERATOR_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OPERATOR_descriptor() {
    return Operator_OPERATOR_descriptor();
  }
  template<typename T>
  static inline const std::string& OPERATOR_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OPERATOR>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OPERATOR_Name.");
    return Operator_OPERATOR_Name(enum_t_value);
  }
  static inline bool OPERATOR_Parse(const std::string& name,
      OPERATOR* value) {
    return Operator_OPERATOR_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vyper.Operator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Operation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {};
  virtual ~Operation();

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const final {
    return CreateMaybeMessage<Operation>(nullptr);
  }

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVal1FieldNumber = 1,
    kVal2FieldNumber = 2,
    kOperatorFieldNumber = 3,
  };
  // .vyper.Value val1 = 1;
  bool has_val1() const;
  private:
  bool _internal_has_val1() const;
  public:
  void clear_val1();
  const ::vyper::Value& val1() const;
  ::vyper::Value* release_val1();
  ::vyper::Value* mutable_val1();
  void set_allocated_val1(::vyper::Value* val1);
  private:
  const ::vyper::Value& _internal_val1() const;
  ::vyper::Value* _internal_mutable_val1();
  public:
  void unsafe_arena_set_allocated_val1(
      ::vyper::Value* val1);
  ::vyper::Value* unsafe_arena_release_val1();

  // .vyper.Value val2 = 2;
  bool has_val2() const;
  private:
  bool _internal_has_val2() const;
  public:
  void clear_val2();
  const ::vyper::Value& val2() const;
  ::vyper::Value* release_val2();
  ::vyper::Value* mutable_val2();
  void set_allocated_val2(::vyper::Value* val2);
  private:
  const ::vyper::Value& _internal_val2() const;
  ::vyper::Value* _internal_mutable_val2();
  public:
  void unsafe_arena_set_allocated_val2(
      ::vyper::Value* val2);
  ::vyper::Value* unsafe_arena_release_val2();

  // .vyper.Operator operator = 3;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;
  public:
  void clear_operator_();
  const ::vyper::Operator& operator_() const;
  ::vyper::Operator* release_operator_();
  ::vyper::Operator* mutable_operator_();
  void set_allocated_operator_(::vyper::Operator* operator_);
  private:
  const ::vyper::Operator& _internal_operator_() const;
  ::vyper::Operator* _internal_mutable_operator_();
  public:
  void unsafe_arena_set_allocated_operator_(
      ::vyper::Operator* operator_);
  ::vyper::Operator* unsafe_arena_release_operator_();

  // @@protoc_insertion_point(class_scope:vyper.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vyper::Value* val1_;
  ::vyper::Value* val2_;
  ::vyper::Operator* operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class ValOrOp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ValOrOp) */ {
 public:
  inline ValOrOp() : ValOrOp(nullptr) {};
  virtual ~ValOrOp();

  ValOrOp(const ValOrOp& from);
  ValOrOp(ValOrOp&& from) noexcept
    : ValOrOp() {
    *this = ::std::move(from);
  }

  inline ValOrOp& operator=(const ValOrOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValOrOp& operator=(ValOrOp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValOrOp& default_instance();

  enum ValueOrOpCase {
    kVal = 1,
    kOp = 2,
    VALUE_OR_OP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValOrOp* internal_default_instance() {
    return reinterpret_cast<const ValOrOp*>(
               &_ValOrOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValOrOp& a, ValOrOp& b) {
    a.Swap(&b);
  }
  inline void Swap(ValOrOp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValOrOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValOrOp* New() const final {
    return CreateMaybeMessage<ValOrOp>(nullptr);
  }

  ValOrOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValOrOp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValOrOp& from);
  void MergeFrom(const ValOrOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValOrOp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.ValOrOp";
  }
  protected:
  explicit ValOrOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
    kOpFieldNumber = 2,
  };
  // .vyper.Value val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::vyper::Value& val() const;
  ::vyper::Value* release_val();
  ::vyper::Value* mutable_val();
  void set_allocated_val(::vyper::Value* val);
  private:
  const ::vyper::Value& _internal_val() const;
  ::vyper::Value* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::vyper::Value* val);
  ::vyper::Value* unsafe_arena_release_val();

  // .vyper.Operation op = 2;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::vyper::Operation& op() const;
  ::vyper::Operation* release_op();
  ::vyper::Operation* mutable_op();
  void set_allocated_op(::vyper::Operation* op);
  private:
  const ::vyper::Operation& _internal_op() const;
  ::vyper::Operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vyper::Operation* op);
  ::vyper::Operation* unsafe_arena_release_op();

  void clear_value_or_op();
  ValueOrOpCase value_or_op_case() const;
  // @@protoc_insertion_point(class_scope:vyper.ValOrOp)
 private:
  class _Internal;
  void set_has_val();
  void set_has_op();

  inline bool has_value_or_op() const;
  inline void clear_has_value_or_op();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueOrOpUnion {
    ValueOrOpUnion() {}
    ::vyper::Value* val_;
    ::vyper::Operation* op_;
  } value_or_op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class CodeBlock PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.CodeBlock) */ {
 public:
  inline CodeBlock() : CodeBlock(nullptr) {};
  virtual ~CodeBlock();

  CodeBlock(const CodeBlock& from);
  CodeBlock(CodeBlock&& from) noexcept
    : CodeBlock() {
    *this = ::std::move(from);
  }

  inline CodeBlock& operator=(const CodeBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeBlock& operator=(CodeBlock&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CodeBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodeBlock* internal_default_instance() {
    return reinterpret_cast<const CodeBlock*>(
               &_CodeBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CodeBlock& a, CodeBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(CodeBlock* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CodeBlock* New() const final {
    return CreateMaybeMessage<CodeBlock>(nullptr);
  }

  CodeBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CodeBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CodeBlock& from);
  void MergeFrom(const CodeBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodeBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.CodeBlock";
  }
  protected:
  explicit CodeBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated .vyper.Statement statements = 1;
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  ::vyper::Statement* mutable_statements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >*
      mutable_statements();
  private:
  const ::vyper::Statement& _internal_statements(int index) const;
  ::vyper::Statement* _internal_add_statements();
  public:
  const ::vyper::Statement& statements(int index) const;
  ::vyper::Statement* add_statements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >&
      statements() const;

  // @@protoc_insertion_point(class_scope:vyper.CodeBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement > statements_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class ArgDef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ArgDef) */ {
 public:
  inline ArgDef() : ArgDef(nullptr) {};
  virtual ~ArgDef();

  ArgDef(const ArgDef& from);
  ArgDef(ArgDef&& from) noexcept
    : ArgDef() {
    *this = ::std::move(from);
  }

  inline ArgDef& operator=(const ArgDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArgDef& operator=(ArgDef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArgDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArgDef* internal_default_instance() {
    return reinterpret_cast<const ArgDef*>(
               &_ArgDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ArgDef& a, ArgDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ArgDef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArgDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArgDef* New() const final {
    return CreateMaybeMessage<ArgDef>(nullptr);
  }

  ArgDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArgDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArgDef& from);
  void MergeFrom(const ArgDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArgDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.ArgDef";
  }
  protected:
  explicit ArgDef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgNameFieldNumber = 1,
    kArgTypeFieldNumber = 2,
  };
  // string arg_name = 1;
  void clear_arg_name();
  const std::string& arg_name() const;
  void set_arg_name(const std::string& value);
  void set_arg_name(std::string&& value);
  void set_arg_name(const char* value);
  void set_arg_name(const char* value, size_t size);
  std::string* mutable_arg_name();
  std::string* release_arg_name();
  void set_allocated_arg_name(std::string* arg_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_arg_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_arg_name(
      std::string* arg_name);
  private:
  const std::string& _internal_arg_name() const;
  void _internal_set_arg_name(const std::string& value);
  std::string* _internal_mutable_arg_name();
  public:

  // .vyper.Type arg_type = 2;
  bool has_arg_type() const;
  private:
  bool _internal_has_arg_type() const;
  public:
  void clear_arg_type();
  const ::vyper::Type& arg_type() const;
  ::vyper::Type* release_arg_type();
  ::vyper::Type* mutable_arg_type();
  void set_allocated_arg_type(::vyper::Type* arg_type);
  private:
  const ::vyper::Type& _internal_arg_type() const;
  ::vyper::Type* _internal_mutable_arg_type();
  public:
  void unsafe_arena_set_allocated_arg_type(
      ::vyper::Type* arg_type);
  ::vyper::Type* unsafe_arena_release_arg_type();

  // @@protoc_insertion_point(class_scope:vyper.ArgDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg_name_;
  ::vyper::Type* arg_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class FunctionDef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.FunctionDef) */ {
 public:
  inline FunctionDef() : FunctionDef(nullptr) {};
  virtual ~FunctionDef();

  FunctionDef(const FunctionDef& from);
  FunctionDef(FunctionDef&& from) noexcept
    : FunctionDef() {
    *this = ::std::move(from);
  }

  inline FunctionDef& operator=(const FunctionDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionDef& operator=(FunctionDef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FunctionDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionDef* internal_default_instance() {
    return reinterpret_cast<const FunctionDef*>(
               &_FunctionDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FunctionDef& a, FunctionDef& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionDef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionDef* New() const final {
    return CreateMaybeMessage<FunctionDef>(nullptr);
  }

  FunctionDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FunctionDef& from);
  void MergeFrom(const FunctionDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.FunctionDef";
  }
  protected:
  explicit FunctionDef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionNameFieldNumber = 1,
    kBlockFieldNumber = 3,
    kReturnTypeFieldNumber = 5,
    kExternalFieldNumber = 4,
  };
  // repeated .vyper.ArgDef args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::vyper::ArgDef* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >*
      mutable_args();
  private:
  const ::vyper::ArgDef& _internal_args(int index) const;
  ::vyper::ArgDef* _internal_add_args();
  public:
  const ::vyper::ArgDef& args(int index) const;
  ::vyper::ArgDef* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >&
      args() const;

  // string function_name = 1;
  void clear_function_name();
  const std::string& function_name() const;
  void set_function_name(const std::string& value);
  void set_function_name(std::string&& value);
  void set_function_name(const char* value);
  void set_function_name(const char* value, size_t size);
  std::string* mutable_function_name();
  std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_function_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_function_name(
      std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // .vyper.CodeBlock block = 3;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::vyper::CodeBlock& block() const;
  ::vyper::CodeBlock* release_block();
  ::vyper::CodeBlock* mutable_block();
  void set_allocated_block(::vyper::CodeBlock* block);
  private:
  const ::vyper::CodeBlock& _internal_block() const;
  ::vyper::CodeBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::vyper::CodeBlock* block);
  ::vyper::CodeBlock* unsafe_arena_release_block();

  // .vyper.Type return_type = 5;
  bool has_return_type() const;
  private:
  bool _internal_has_return_type() const;
  public:
  void clear_return_type();
  const ::vyper::Type& return_type() const;
  ::vyper::Type* release_return_type();
  ::vyper::Type* mutable_return_type();
  void set_allocated_return_type(::vyper::Type* return_type);
  private:
  const ::vyper::Type& _internal_return_type() const;
  ::vyper::Type* _internal_mutable_return_type();
  public:
  void unsafe_arena_set_allocated_return_type(
      ::vyper::Type* return_type);
  ::vyper::Type* unsafe_arena_release_return_type();

  // bool external = 4;
  void clear_external();
  bool external() const;
  void set_external(bool value);
  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vyper.FunctionDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef > args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  ::vyper::CodeBlock* block_;
  ::vyper::Type* return_type_;
  bool external_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Type PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Type) */ {
 public:
  inline Type() : Type(nullptr) {};
  virtual ~Type();

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(nullptr);
  }

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeValFieldNumber = 1,
  };
  // .vyper.TYPE_ENUM typeVal = 1;
  void clear_typeval();
  ::vyper::TYPE_ENUM typeval() const;
  void set_typeval(::vyper::TYPE_ENUM value);
  private:
  ::vyper::TYPE_ENUM _internal_typeval() const;
  void _internal_set_typeval(::vyper::TYPE_ENUM value);
  public:

  // @@protoc_insertion_point(class_scope:vyper.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int typeval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class Assignment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Assignment) */ {
 public:
  inline Assignment() : Assignment(nullptr) {};
  virtual ~Assignment();

  Assignment(const Assignment& from);
  Assignment(Assignment&& from) noexcept
    : Assignment() {
    *this = ::std::move(from);
  }

  inline Assignment& operator=(const Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assignment& operator=(Assignment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Assignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Assignment* internal_default_instance() {
    return reinterpret_cast<const Assignment*>(
               &_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Assignment& a, Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(Assignment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Assignment* New() const final {
    return CreateMaybeMessage<Assignment>(nullptr);
  }

  Assignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Assignment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Assignment& from);
  void MergeFrom(const Assignment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assignment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.Assignment";
  }
  protected:
  explicit Assignment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariableNameFieldNumber = 1,
    kValueFieldNumber = 3,
  };
  // string variable_name = 1;
  void clear_variable_name();
  const std::string& variable_name() const;
  void set_variable_name(const std::string& value);
  void set_variable_name(std::string&& value);
  void set_variable_name(const char* value);
  void set_variable_name(const char* value, size_t size);
  std::string* mutable_variable_name();
  std::string* release_variable_name();
  void set_allocated_variable_name(std::string* variable_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_variable_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_variable_name(
      std::string* variable_name);
  private:
  const std::string& _internal_variable_name() const;
  void _internal_set_variable_name(const std::string& value);
  std::string* _internal_mutable_variable_name();
  public:

  // .vyper.ValOrOp value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::vyper::ValOrOp& value() const;
  ::vyper::ValOrOp* release_value();
  ::vyper::ValOrOp* mutable_value();
  void set_allocated_value(::vyper::ValOrOp* value);
  private:
  const ::vyper::ValOrOp& _internal_value() const;
  ::vyper::ValOrOp* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::vyper::ValOrOp* value);
  ::vyper::ValOrOp* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:vyper.Assignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_name_;
  ::vyper::ValOrOp* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class IfStatement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.IfStatement) */ {
 public:
  inline IfStatement() : IfStatement(nullptr) {};
  virtual ~IfStatement();

  IfStatement(const IfStatement& from);
  IfStatement(IfStatement&& from) noexcept
    : IfStatement() {
    *this = ::std::move(from);
  }

  inline IfStatement& operator=(const IfStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfStatement& operator=(IfStatement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IfStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfStatement* internal_default_instance() {
    return reinterpret_cast<const IfStatement*>(
               &_IfStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IfStatement& a, IfStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(IfStatement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfStatement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IfStatement* New() const final {
    return CreateMaybeMessage<IfStatement>(nullptr);
  }

  IfStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IfStatement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IfStatement& from);
  void MergeFrom(const IfStatement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfStatement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.IfStatement";
  }
  protected:
  explicit IfStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 1,
    kBlockFieldNumber = 2,
  };
  // string condition = 1;
  void clear_condition();
  const std::string& condition() const;
  void set_condition(const std::string& value);
  void set_condition(std::string&& value);
  void set_condition(const char* value);
  void set_condition(const char* value, size_t size);
  std::string* mutable_condition();
  std::string* release_condition();
  void set_allocated_condition(std::string* condition);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_condition();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_condition(
      std::string* condition);
  private:
  const std::string& _internal_condition() const;
  void _internal_set_condition(const std::string& value);
  std::string* _internal_mutable_condition();
  public:

  // .vyper.CodeBlock block = 2;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::vyper::CodeBlock& block() const;
  ::vyper::CodeBlock* release_block();
  ::vyper::CodeBlock* mutable_block();
  void set_allocated_block(::vyper::CodeBlock* block);
  private:
  const ::vyper::CodeBlock& _internal_block() const;
  ::vyper::CodeBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::vyper::CodeBlock* block);
  ::vyper::CodeBlock* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:vyper.IfStatement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_;
  ::vyper::CodeBlock* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class FunctionCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.FunctionCall) */ {
 public:
  inline FunctionCall() : FunctionCall(nullptr) {};
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FunctionCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionCall* New() const final {
    return CreateMaybeMessage<FunctionCall>(nullptr);
  }

  FunctionCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.FunctionCall";
  }
  protected:
  explicit FunctionCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kFunctionNameFieldNumber = 1,
  };
  // repeated .vyper.ValOrOp args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::vyper::ValOrOp* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >*
      mutable_args();
  private:
  const ::vyper::ValOrOp& _internal_args(int index) const;
  ::vyper::ValOrOp* _internal_add_args();
  public:
  const ::vyper::ValOrOp& args(int index) const;
  ::vyper::ValOrOp* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >&
      args() const;

  // string function_name = 1;
  void clear_function_name();
  const std::string& function_name() const;
  void set_function_name(const std::string& value);
  void set_function_name(std::string&& value);
  void set_function_name(const char* value);
  void set_function_name(const char* value, size_t size);
  std::string* mutable_function_name();
  std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_function_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_function_name(
      std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // @@protoc_insertion_point(class_scope:vyper.FunctionCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp > args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class ConcatCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ConcatCall) */ {
 public:
  inline ConcatCall() : ConcatCall(nullptr) {};
  virtual ~ConcatCall();

  ConcatCall(const ConcatCall& from);
  ConcatCall(ConcatCall&& from) noexcept
    : ConcatCall() {
    *this = ::std::move(from);
  }

  inline ConcatCall& operator=(const ConcatCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConcatCall& operator=(ConcatCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConcatCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConcatCall* internal_default_instance() {
    return reinterpret_cast<const ConcatCall*>(
               &_ConcatCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ConcatCall& a, ConcatCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ConcatCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConcatCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConcatCall* New() const final {
    return CreateMaybeMessage<ConcatCall>(nullptr);
  }

  ConcatCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConcatCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConcatCall& from);
  void MergeFrom(const ConcatCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConcatCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.ConcatCall";
  }
  protected:
  explicit ConcatCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
  };
  // repeated string args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // @@protoc_insertion_point(class_scope:vyper.ConcatCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class ConvertCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ConvertCall) */ {
 public:
  inline ConvertCall() : ConvertCall(nullptr) {};
  virtual ~ConvertCall();

  ConvertCall(const ConvertCall& from);
  ConvertCall(ConvertCall&& from) noexcept
    : ConvertCall() {
    *this = ::std::move(from);
  }

  inline ConvertCall& operator=(const ConvertCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertCall& operator=(ConvertCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConvertCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConvertCall* internal_default_instance() {
    return reinterpret_cast<const ConvertCall*>(
               &_ConvertCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ConvertCall& a, ConvertCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConvertCall* New() const final {
    return CreateMaybeMessage<ConvertCall>(nullptr);
  }

  ConvertCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConvertCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConvertCall& from);
  void MergeFrom(const ConvertCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.ConvertCall";
  }
  protected:
  explicit ConvertCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // .vyper.ValOrOp value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::vyper::ValOrOp& value() const;
  ::vyper::ValOrOp* release_value();
  ::vyper::ValOrOp* mutable_value();
  void set_allocated_value(::vyper::ValOrOp* value);
  private:
  const ::vyper::ValOrOp& _internal_value() const;
  ::vyper::ValOrOp* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::vyper::ValOrOp* value);
  ::vyper::ValOrOp* unsafe_arena_release_value();

  // .vyper.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::vyper::Type& type() const;
  ::vyper::Type* release_type();
  ::vyper::Type* mutable_type();
  void set_allocated_type(::vyper::Type* type);
  private:
  const ::vyper::Type& _internal_type() const;
  ::vyper::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::vyper::Type* type);
  ::vyper::Type* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:vyper.ConvertCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vyper::ValOrOp* value_;
  ::vyper::Type* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class BuiltinCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.BuiltinCall) */ {
 public:
  inline BuiltinCall() : BuiltinCall(nullptr) {};
  virtual ~BuiltinCall();

  BuiltinCall(const BuiltinCall& from);
  BuiltinCall(BuiltinCall&& from) noexcept
    : BuiltinCall() {
    *this = ::std::move(from);
  }

  inline BuiltinCall& operator=(const BuiltinCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuiltinCall& operator=(BuiltinCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuiltinCall& default_instance();

  enum CallCase {
    kConcat = 1,
    kConvert = 2,
    CALL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuiltinCall* internal_default_instance() {
    return reinterpret_cast<const BuiltinCall*>(
               &_BuiltinCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BuiltinCall& a, BuiltinCall& b) {
    a.Swap(&b);
  }
  inline void Swap(BuiltinCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuiltinCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuiltinCall* New() const final {
    return CreateMaybeMessage<BuiltinCall>(nullptr);
  }

  BuiltinCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuiltinCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuiltinCall& from);
  void MergeFrom(const BuiltinCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.BuiltinCall";
  }
  protected:
  explicit BuiltinCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConcatFieldNumber = 1,
    kConvertFieldNumber = 2,
  };
  // .vyper.ConcatCall concat = 1;
  bool has_concat() const;
  private:
  bool _internal_has_concat() const;
  public:
  void clear_concat();
  const ::vyper::ConcatCall& concat() const;
  ::vyper::ConcatCall* release_concat();
  ::vyper::ConcatCall* mutable_concat();
  void set_allocated_concat(::vyper::ConcatCall* concat);
  private:
  const ::vyper::ConcatCall& _internal_concat() const;
  ::vyper::ConcatCall* _internal_mutable_concat();
  public:
  void unsafe_arena_set_allocated_concat(
      ::vyper::ConcatCall* concat);
  ::vyper::ConcatCall* unsafe_arena_release_concat();

  // .vyper.ConvertCall convert = 2;
  bool has_convert() const;
  private:
  bool _internal_has_convert() const;
  public:
  void clear_convert();
  const ::vyper::ConvertCall& convert() const;
  ::vyper::ConvertCall* release_convert();
  ::vyper::ConvertCall* mutable_convert();
  void set_allocated_convert(::vyper::ConvertCall* convert);
  private:
  const ::vyper::ConvertCall& _internal_convert() const;
  ::vyper::ConvertCall* _internal_mutable_convert();
  public:
  void unsafe_arena_set_allocated_convert(
      ::vyper::ConvertCall* convert);
  ::vyper::ConvertCall* unsafe_arena_release_convert();

  void clear_call();
  CallCase call_case() const;
  // @@protoc_insertion_point(class_scope:vyper.BuiltinCall)
 private:
  class _Internal;
  void set_has_concat();
  void set_has_convert();

  inline bool has_call() const;
  inline void clear_has_call();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CallUnion {
    CallUnion() {}
    ::vyper::ConcatCall* concat_;
    ::vyper::ConvertCall* convert_;
  } call_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vyper_2eproto;
};
// -------------------------------------------------------------------

class VyperContract PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.VyperContract) */ {
 public:
  inline VyperContract() : VyperContract(nullptr) {};
  virtual ~VyperContract();

  VyperContract(const VyperContract& from);
  VyperContract(VyperContract&& from) noexcept
    : VyperContract() {
    *this = ::std::move(from);
  }

  inline VyperContract& operator=(const VyperContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VyperContract& operator=(VyperContract&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VyperContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VyperContract* internal_default_instance() {
    return reinterpret_cast<const VyperContract*>(
               &_VyperContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VyperContract& a, VyperContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VyperContract* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VyperContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VyperContract* New() const final {
    return CreateMaybeMessage<VyperContract>(nullptr);
  }

  VyperContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VyperContract>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VyperContract& from);
  void MergeFrom(const VyperContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VyperContract* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vyper.VyperContract";
  }
  protected:
  explicit VyperContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vyper_2eproto);
    return ::descriptor_table_vyper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionsFieldNumber = 1,
  };
  // repeated .vyper.FunctionDef functions = 1;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  ::vyper::FunctionDef* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >*
      mutable_functions();
  private:
  const ::vyper::FunctionDef& _internal_functions(int index) const;
  ::vyper::FunctionDef* _internal_add_functions();
  public:
  const ::vyper::FunctionDef& functions(int index) const;
  ::vyper::FunctionDef* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >&
      functions() const;

  // @@protoc_insertion_point(class_scope:vyper.VyperContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef > functions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vyper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Statement

// .vyper.Assignment assignment = 1;
inline bool Statement::_internal_has_assignment() const {
  return statement_case() == kAssignment;
}
inline bool Statement::has_assignment() const {
  return _internal_has_assignment();
}
inline void Statement::set_has_assignment() {
  _oneof_case_[0] = kAssignment;
}
inline void Statement::clear_assignment() {
  if (_internal_has_assignment()) {
    if (GetArena() == nullptr) {
      delete statement_.assignment_;
    }
    clear_has_statement();
  }
}
inline ::vyper::Assignment* Statement::release_assignment() {
  // @@protoc_insertion_point(field_release:vyper.Statement.assignment)
  if (_internal_has_assignment()) {
    clear_has_statement();
      ::vyper::Assignment* temp = statement_.assignment_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    statement_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Assignment& Statement::_internal_assignment() const {
  return _internal_has_assignment()
      ? *statement_.assignment_
      : *reinterpret_cast< ::vyper::Assignment*>(&::vyper::_Assignment_default_instance_);
}
inline const ::vyper::Assignment& Statement::assignment() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.assignment)
  return _internal_assignment();
}
inline ::vyper::Assignment* Statement::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.assignment)
  if (_internal_has_assignment()) {
    clear_has_statement();
    ::vyper::Assignment* temp = statement_.assignment_;
    statement_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_assignment(::vyper::Assignment* assignment) {
  clear_statement();
  if (assignment) {
    set_has_assignment();
    statement_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.assignment)
}
inline ::vyper::Assignment* Statement::_internal_mutable_assignment() {
  if (!_internal_has_assignment()) {
    clear_statement();
    set_has_assignment();
    statement_.assignment_ = CreateMaybeMessage< ::vyper::Assignment >(GetArena());
  }
  return statement_.assignment_;
}
inline ::vyper::Assignment* Statement::mutable_assignment() {
  // @@protoc_insertion_point(field_mutable:vyper.Statement.assignment)
  return _internal_mutable_assignment();
}

// .vyper.IfStatement if_statement = 2;
inline bool Statement::_internal_has_if_statement() const {
  return statement_case() == kIfStatement;
}
inline bool Statement::has_if_statement() const {
  return _internal_has_if_statement();
}
inline void Statement::set_has_if_statement() {
  _oneof_case_[0] = kIfStatement;
}
inline void Statement::clear_if_statement() {
  if (_internal_has_if_statement()) {
    if (GetArena() == nullptr) {
      delete statement_.if_statement_;
    }
    clear_has_statement();
  }
}
inline ::vyper::IfStatement* Statement::release_if_statement() {
  // @@protoc_insertion_point(field_release:vyper.Statement.if_statement)
  if (_internal_has_if_statement()) {
    clear_has_statement();
      ::vyper::IfStatement* temp = statement_.if_statement_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    statement_.if_statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::IfStatement& Statement::_internal_if_statement() const {
  return _internal_has_if_statement()
      ? *statement_.if_statement_
      : *reinterpret_cast< ::vyper::IfStatement*>(&::vyper::_IfStatement_default_instance_);
}
inline const ::vyper::IfStatement& Statement::if_statement() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.if_statement)
  return _internal_if_statement();
}
inline ::vyper::IfStatement* Statement::unsafe_arena_release_if_statement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.if_statement)
  if (_internal_has_if_statement()) {
    clear_has_statement();
    ::vyper::IfStatement* temp = statement_.if_statement_;
    statement_.if_statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_if_statement(::vyper::IfStatement* if_statement) {
  clear_statement();
  if (if_statement) {
    set_has_if_statement();
    statement_.if_statement_ = if_statement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.if_statement)
}
inline ::vyper::IfStatement* Statement::_internal_mutable_if_statement() {
  if (!_internal_has_if_statement()) {
    clear_statement();
    set_has_if_statement();
    statement_.if_statement_ = CreateMaybeMessage< ::vyper::IfStatement >(GetArena());
  }
  return statement_.if_statement_;
}
inline ::vyper::IfStatement* Statement::mutable_if_statement() {
  // @@protoc_insertion_point(field_mutable:vyper.Statement.if_statement)
  return _internal_mutable_if_statement();
}

// .vyper.FunctionCall function_call = 3;
inline bool Statement::_internal_has_function_call() const {
  return statement_case() == kFunctionCall;
}
inline bool Statement::has_function_call() const {
  return _internal_has_function_call();
}
inline void Statement::set_has_function_call() {
  _oneof_case_[0] = kFunctionCall;
}
inline void Statement::clear_function_call() {
  if (_internal_has_function_call()) {
    if (GetArena() == nullptr) {
      delete statement_.function_call_;
    }
    clear_has_statement();
  }
}
inline ::vyper::FunctionCall* Statement::release_function_call() {
  // @@protoc_insertion_point(field_release:vyper.Statement.function_call)
  if (_internal_has_function_call()) {
    clear_has_statement();
      ::vyper::FunctionCall* temp = statement_.function_call_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    statement_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::FunctionCall& Statement::_internal_function_call() const {
  return _internal_has_function_call()
      ? *statement_.function_call_
      : *reinterpret_cast< ::vyper::FunctionCall*>(&::vyper::_FunctionCall_default_instance_);
}
inline const ::vyper::FunctionCall& Statement::function_call() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.function_call)
  return _internal_function_call();
}
inline ::vyper::FunctionCall* Statement::unsafe_arena_release_function_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.function_call)
  if (_internal_has_function_call()) {
    clear_has_statement();
    ::vyper::FunctionCall* temp = statement_.function_call_;
    statement_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_function_call(::vyper::FunctionCall* function_call) {
  clear_statement();
  if (function_call) {
    set_has_function_call();
    statement_.function_call_ = function_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.function_call)
}
inline ::vyper::FunctionCall* Statement::_internal_mutable_function_call() {
  if (!_internal_has_function_call()) {
    clear_statement();
    set_has_function_call();
    statement_.function_call_ = CreateMaybeMessage< ::vyper::FunctionCall >(GetArena());
  }
  return statement_.function_call_;
}
inline ::vyper::FunctionCall* Statement::mutable_function_call() {
  // @@protoc_insertion_point(field_mutable:vyper.Statement.function_call)
  return _internal_mutable_function_call();
}

// .vyper.BuiltinCall builtin_call = 4;
inline bool Statement::_internal_has_builtin_call() const {
  return statement_case() == kBuiltinCall;
}
inline bool Statement::has_builtin_call() const {
  return _internal_has_builtin_call();
}
inline void Statement::set_has_builtin_call() {
  _oneof_case_[0] = kBuiltinCall;
}
inline void Statement::clear_builtin_call() {
  if (_internal_has_builtin_call()) {
    if (GetArena() == nullptr) {
      delete statement_.builtin_call_;
    }
    clear_has_statement();
  }
}
inline ::vyper::BuiltinCall* Statement::release_builtin_call() {
  // @@protoc_insertion_point(field_release:vyper.Statement.builtin_call)
  if (_internal_has_builtin_call()) {
    clear_has_statement();
      ::vyper::BuiltinCall* temp = statement_.builtin_call_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    statement_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::BuiltinCall& Statement::_internal_builtin_call() const {
  return _internal_has_builtin_call()
      ? *statement_.builtin_call_
      : *reinterpret_cast< ::vyper::BuiltinCall*>(&::vyper::_BuiltinCall_default_instance_);
}
inline const ::vyper::BuiltinCall& Statement::builtin_call() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.builtin_call)
  return _internal_builtin_call();
}
inline ::vyper::BuiltinCall* Statement::unsafe_arena_release_builtin_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.builtin_call)
  if (_internal_has_builtin_call()) {
    clear_has_statement();
    ::vyper::BuiltinCall* temp = statement_.builtin_call_;
    statement_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call) {
  clear_statement();
  if (builtin_call) {
    set_has_builtin_call();
    statement_.builtin_call_ = builtin_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.builtin_call)
}
inline ::vyper::BuiltinCall* Statement::_internal_mutable_builtin_call() {
  if (!_internal_has_builtin_call()) {
    clear_statement();
    set_has_builtin_call();
    statement_.builtin_call_ = CreateMaybeMessage< ::vyper::BuiltinCall >(GetArena());
  }
  return statement_.builtin_call_;
}
inline ::vyper::BuiltinCall* Statement::mutable_builtin_call() {
  // @@protoc_insertion_point(field_mutable:vyper.Statement.builtin_call)
  return _internal_mutable_builtin_call();
}

inline bool Statement::has_statement() const {
  return statement_case() != STATEMENT_NOT_SET;
}
inline void Statement::clear_has_statement() {
  _oneof_case_[0] = STATEMENT_NOT_SET;
}
inline Statement::StatementCase Statement::statement_case() const {
  return Statement::StatementCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Uint256

// uint64 hb = 1;
inline void Uint256::clear_hb() {
  hb_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint256::_internal_hb() const {
  return hb_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint256::hb() const {
  // @@protoc_insertion_point(field_get:vyper.Uint256.hb)
  return _internal_hb();
}
inline void Uint256::_internal_set_hb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  hb_ = value;
}
inline void Uint256::set_hb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_hb(value);
  // @@protoc_insertion_point(field_set:vyper.Uint256.hb)
}

// uint64 lb = 2;
inline void Uint256::clear_lb() {
  lb_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint256::_internal_lb() const {
  return lb_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint256::lb() const {
  // @@protoc_insertion_point(field_get:vyper.Uint256.lb)
  return _internal_lb();
}
inline void Uint256::_internal_set_lb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  lb_ = value;
}
inline void Uint256::set_lb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lb(value);
  // @@protoc_insertion_point(field_set:vyper.Uint256.lb)
}

// -------------------------------------------------------------------

// Value

// string str_literal = 1;
inline bool Value::_internal_has_str_literal() const {
  return value_case() == kStrLiteral;
}
inline void Value::set_has_str_literal() {
  _oneof_case_[0] = kStrLiteral;
}
inline void Value::clear_str_literal() {
  if (_internal_has_str_literal()) {
    value_.str_literal_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_value();
  }
}
inline const std::string& Value::str_literal() const {
  // @@protoc_insertion_point(field_get:vyper.Value.str_literal)
  return _internal_str_literal();
}
inline void Value::set_str_literal(const std::string& value) {
  _internal_set_str_literal(value);
  // @@protoc_insertion_point(field_set:vyper.Value.str_literal)
}
inline std::string* Value::mutable_str_literal() {
  // @@protoc_insertion_point(field_mutable:vyper.Value.str_literal)
  return _internal_mutable_str_literal();
}
inline const std::string& Value::_internal_str_literal() const {
  if (_internal_has_str_literal()) {
    return value_.str_literal_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_str_literal(const std::string& value) {
  if (!_internal_has_str_literal()) {
    clear_value();
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.str_literal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_str_literal(std::string&& value) {
  // @@protoc_insertion_point(field_set:vyper.Value.str_literal)
  if (!_internal_has_str_literal()) {
    clear_value();
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.str_literal_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.Value.str_literal)
}
inline void Value::set_str_literal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_str_literal()) {
    clear_value();
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.str_literal_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.Value.str_literal)
}
inline void Value::set_str_literal(const char* value,
                             size_t size) {
  if (!_internal_has_str_literal()) {
    clear_value();
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.str_literal_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.Value.str_literal)
}
inline std::string* Value::_internal_mutable_str_literal() {
  if (!_internal_has_str_literal()) {
    clear_value();
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.str_literal_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_str_literal() {
  // @@protoc_insertion_point(field_release:vyper.Value.str_literal)
  if (_internal_has_str_literal()) {
    clear_has_value();
    return value_.str_literal_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_str_literal(std::string* str_literal) {
  if (has_value()) {
    clear_value();
  }
  if (str_literal != nullptr) {
    set_has_str_literal();
    value_.str_literal_.UnsafeSetDefault(str_literal);
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Value.str_literal)
}
inline std::string* Value::unsafe_arena_release_str_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Value.str_literal)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_str_literal()) {
    clear_has_value();
    return value_.str_literal_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_str_literal(std::string* str_literal) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_str_literal()) {
    value_.str_literal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (str_literal) {
    set_has_str_literal();
    value_.str_literal_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), str_literal, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Value.str_literal)
}

// string var_name = 2;
inline bool Value::_internal_has_var_name() const {
  return value_case() == kVarName;
}
inline void Value::set_has_var_name() {
  _oneof_case_[0] = kVarName;
}
inline void Value::clear_var_name() {
  if (_internal_has_var_name()) {
    value_.var_name_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_value();
  }
}
inline const std::string& Value::var_name() const {
  // @@protoc_insertion_point(field_get:vyper.Value.var_name)
  return _internal_var_name();
}
inline void Value::set_var_name(const std::string& value) {
  _internal_set_var_name(value);
  // @@protoc_insertion_point(field_set:vyper.Value.var_name)
}
inline std::string* Value::mutable_var_name() {
  // @@protoc_insertion_point(field_mutable:vyper.Value.var_name)
  return _internal_mutable_var_name();
}
inline const std::string& Value::_internal_var_name() const {
  if (_internal_has_var_name()) {
    return value_.var_name_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_var_name(const std::string& value) {
  if (!_internal_has_var_name()) {
    clear_value();
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.var_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_var_name(std::string&& value) {
  // @@protoc_insertion_point(field_set:vyper.Value.var_name)
  if (!_internal_has_var_name()) {
    clear_value();
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.var_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.Value.var_name)
}
inline void Value::set_var_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_var_name()) {
    clear_value();
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.var_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.Value.var_name)
}
inline void Value::set_var_name(const char* value,
                             size_t size) {
  if (!_internal_has_var_name()) {
    clear_value();
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.var_name_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.Value.var_name)
}
inline std::string* Value::_internal_mutable_var_name() {
  if (!_internal_has_var_name()) {
    clear_value();
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.var_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_var_name() {
  // @@protoc_insertion_point(field_release:vyper.Value.var_name)
  if (_internal_has_var_name()) {
    clear_has_value();
    return value_.var_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_var_name(std::string* var_name) {
  if (has_value()) {
    clear_value();
  }
  if (var_name != nullptr) {
    set_has_var_name();
    value_.var_name_.UnsafeSetDefault(var_name);
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Value.var_name)
}
inline std::string* Value::unsafe_arena_release_var_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Value.var_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_var_name()) {
    clear_has_value();
    return value_.var_name_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_var_name(std::string* var_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_var_name()) {
    value_.var_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (var_name) {
    set_has_var_name();
    value_.var_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), var_name, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Value.var_name)
}

// .vyper.Uint256 num = 3;
inline bool Value::_internal_has_num() const {
  return value_case() == kNum;
}
inline bool Value::has_num() const {
  return _internal_has_num();
}
inline void Value::set_has_num() {
  _oneof_case_[0] = kNum;
}
inline void Value::clear_num() {
  if (_internal_has_num()) {
    if (GetArena() == nullptr) {
      delete value_.num_;
    }
    clear_has_value();
  }
}
inline ::vyper::Uint256* Value::release_num() {
  // @@protoc_insertion_point(field_release:vyper.Value.num)
  if (_internal_has_num()) {
    clear_has_value();
      ::vyper::Uint256* temp = value_.num_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.num_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Uint256& Value::_internal_num() const {
  return _internal_has_num()
      ? *value_.num_
      : *reinterpret_cast< ::vyper::Uint256*>(&::vyper::_Uint256_default_instance_);
}
inline const ::vyper::Uint256& Value::num() const {
  // @@protoc_insertion_point(field_get:vyper.Value.num)
  return _internal_num();
}
inline ::vyper::Uint256* Value::unsafe_arena_release_num() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Value.num)
  if (_internal_has_num()) {
    clear_has_value();
    ::vyper::Uint256* temp = value_.num_;
    value_.num_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_num(::vyper::Uint256* num) {
  clear_value();
  if (num) {
    set_has_num();
    value_.num_ = num;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Value.num)
}
inline ::vyper::Uint256* Value::_internal_mutable_num() {
  if (!_internal_has_num()) {
    clear_value();
    set_has_num();
    value_.num_ = CreateMaybeMessage< ::vyper::Uint256 >(GetArena());
  }
  return value_.num_;
}
inline ::vyper::Uint256* Value::mutable_num() {
  // @@protoc_insertion_point(field_mutable:vyper.Value.num)
  return _internal_mutable_num();
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Operator

// -------------------------------------------------------------------

// Operation

// .vyper.Value val1 = 1;
inline bool Operation::_internal_has_val1() const {
  return this != internal_default_instance() && val1_ != nullptr;
}
inline bool Operation::has_val1() const {
  return _internal_has_val1();
}
inline void Operation::clear_val1() {
  if (GetArena() == nullptr && val1_ != nullptr) {
    delete val1_;
  }
  val1_ = nullptr;
}
inline const ::vyper::Value& Operation::_internal_val1() const {
  const ::vyper::Value* p = val1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Value*>(
      &::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& Operation::val1() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.val1)
  return _internal_val1();
}
inline void Operation::unsafe_arena_set_allocated_val1(
    ::vyper::Value* val1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(val1_);
  }
  val1_ = val1;
  if (val1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.val1)
}
inline ::vyper::Value* Operation::release_val1() {
  auto temp = unsafe_arena_release_val1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Value* Operation::unsafe_arena_release_val1() {
  // @@protoc_insertion_point(field_release:vyper.Operation.val1)
  
  ::vyper::Value* temp = val1_;
  val1_ = nullptr;
  return temp;
}
inline ::vyper::Value* Operation::_internal_mutable_val1() {
  
  if (val1_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Value>(GetArena());
    val1_ = p;
  }
  return val1_;
}
inline ::vyper::Value* Operation::mutable_val1() {
  // @@protoc_insertion_point(field_mutable:vyper.Operation.val1)
  return _internal_mutable_val1();
}
inline void Operation::set_allocated_val1(::vyper::Value* val1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete val1_;
  }
  if (val1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(val1);
    if (message_arena != submessage_arena) {
      val1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val1, submessage_arena);
    }
    
  } else {
    
  }
  val1_ = val1;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.val1)
}

// .vyper.Value val2 = 2;
inline bool Operation::_internal_has_val2() const {
  return this != internal_default_instance() && val2_ != nullptr;
}
inline bool Operation::has_val2() const {
  return _internal_has_val2();
}
inline void Operation::clear_val2() {
  if (GetArena() == nullptr && val2_ != nullptr) {
    delete val2_;
  }
  val2_ = nullptr;
}
inline const ::vyper::Value& Operation::_internal_val2() const {
  const ::vyper::Value* p = val2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Value*>(
      &::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& Operation::val2() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.val2)
  return _internal_val2();
}
inline void Operation::unsafe_arena_set_allocated_val2(
    ::vyper::Value* val2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(val2_);
  }
  val2_ = val2;
  if (val2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.val2)
}
inline ::vyper::Value* Operation::release_val2() {
  auto temp = unsafe_arena_release_val2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Value* Operation::unsafe_arena_release_val2() {
  // @@protoc_insertion_point(field_release:vyper.Operation.val2)
  
  ::vyper::Value* temp = val2_;
  val2_ = nullptr;
  return temp;
}
inline ::vyper::Value* Operation::_internal_mutable_val2() {
  
  if (val2_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Value>(GetArena());
    val2_ = p;
  }
  return val2_;
}
inline ::vyper::Value* Operation::mutable_val2() {
  // @@protoc_insertion_point(field_mutable:vyper.Operation.val2)
  return _internal_mutable_val2();
}
inline void Operation::set_allocated_val2(::vyper::Value* val2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete val2_;
  }
  if (val2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(val2);
    if (message_arena != submessage_arena) {
      val2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val2, submessage_arena);
    }
    
  } else {
    
  }
  val2_ = val2;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.val2)
}

// .vyper.Operator operator = 3;
inline bool Operation::_internal_has_operator_() const {
  return this != internal_default_instance() && operator__ != nullptr;
}
inline bool Operation::has_operator_() const {
  return _internal_has_operator_();
}
inline void Operation::clear_operator_() {
  if (GetArena() == nullptr && operator__ != nullptr) {
    delete operator__;
  }
  operator__ = nullptr;
}
inline const ::vyper::Operator& Operation::_internal_operator_() const {
  const ::vyper::Operator* p = operator__;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Operator*>(
      &::vyper::_Operator_default_instance_);
}
inline const ::vyper::Operator& Operation::operator_() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.operator)
  return _internal_operator_();
}
inline void Operation::unsafe_arena_set_allocated_operator_(
    ::vyper::Operator* operator_) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operator__);
  }
  operator__ = operator_;
  if (operator_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.operator)
}
inline ::vyper::Operator* Operation::release_operator_() {
  auto temp = unsafe_arena_release_operator_();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Operator* Operation::unsafe_arena_release_operator_() {
  // @@protoc_insertion_point(field_release:vyper.Operation.operator)
  
  ::vyper::Operator* temp = operator__;
  operator__ = nullptr;
  return temp;
}
inline ::vyper::Operator* Operation::_internal_mutable_operator_() {
  
  if (operator__ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Operator>(GetArena());
    operator__ = p;
  }
  return operator__;
}
inline ::vyper::Operator* Operation::mutable_operator_() {
  // @@protoc_insertion_point(field_mutable:vyper.Operation.operator)
  return _internal_mutable_operator_();
}
inline void Operation::set_allocated_operator_(::vyper::Operator* operator_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete operator__;
  }
  if (operator_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(operator_);
    if (message_arena != submessage_arena) {
      operator_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operator_, submessage_arena);
    }
    
  } else {
    
  }
  operator__ = operator_;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.operator)
}

// -------------------------------------------------------------------

// ValOrOp

// .vyper.Value val = 1;
inline bool ValOrOp::_internal_has_val() const {
  return value_or_op_case() == kVal;
}
inline bool ValOrOp::has_val() const {
  return _internal_has_val();
}
inline void ValOrOp::set_has_val() {
  _oneof_case_[0] = kVal;
}
inline void ValOrOp::clear_val() {
  if (_internal_has_val()) {
    if (GetArena() == nullptr) {
      delete value_or_op_.val_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::Value* ValOrOp::release_val() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.val)
  if (_internal_has_val()) {
    clear_has_value_or_op();
      ::vyper::Value* temp = value_or_op_.val_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_or_op_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Value& ValOrOp::_internal_val() const {
  return _internal_has_val()
      ? *value_or_op_.val_
      : *reinterpret_cast< ::vyper::Value*>(&::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& ValOrOp::val() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.val)
  return _internal_val();
}
inline ::vyper::Value* ValOrOp::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.val)
  if (_internal_has_val()) {
    clear_has_value_or_op();
    ::vyper::Value* temp = value_or_op_.val_;
    value_or_op_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_val(::vyper::Value* val) {
  clear_value_or_op();
  if (val) {
    set_has_val();
    value_or_op_.val_ = val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.val)
}
inline ::vyper::Value* ValOrOp::_internal_mutable_val() {
  if (!_internal_has_val()) {
    clear_value_or_op();
    set_has_val();
    value_or_op_.val_ = CreateMaybeMessage< ::vyper::Value >(GetArena());
  }
  return value_or_op_.val_;
}
inline ::vyper::Value* ValOrOp::mutable_val() {
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.val)
  return _internal_mutable_val();
}

// .vyper.Operation op = 2;
inline bool ValOrOp::_internal_has_op() const {
  return value_or_op_case() == kOp;
}
inline bool ValOrOp::has_op() const {
  return _internal_has_op();
}
inline void ValOrOp::set_has_op() {
  _oneof_case_[0] = kOp;
}
inline void ValOrOp::clear_op() {
  if (_internal_has_op()) {
    if (GetArena() == nullptr) {
      delete value_or_op_.op_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::Operation* ValOrOp::release_op() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.op)
  if (_internal_has_op()) {
    clear_has_value_or_op();
      ::vyper::Operation* temp = value_or_op_.op_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_or_op_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Operation& ValOrOp::_internal_op() const {
  return _internal_has_op()
      ? *value_or_op_.op_
      : *reinterpret_cast< ::vyper::Operation*>(&::vyper::_Operation_default_instance_);
}
inline const ::vyper::Operation& ValOrOp::op() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.op)
  return _internal_op();
}
inline ::vyper::Operation* ValOrOp::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.op)
  if (_internal_has_op()) {
    clear_has_value_or_op();
    ::vyper::Operation* temp = value_or_op_.op_;
    value_or_op_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_op(::vyper::Operation* op) {
  clear_value_or_op();
  if (op) {
    set_has_op();
    value_or_op_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.op)
}
inline ::vyper::Operation* ValOrOp::_internal_mutable_op() {
  if (!_internal_has_op()) {
    clear_value_or_op();
    set_has_op();
    value_or_op_.op_ = CreateMaybeMessage< ::vyper::Operation >(GetArena());
  }
  return value_or_op_.op_;
}
inline ::vyper::Operation* ValOrOp::mutable_op() {
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.op)
  return _internal_mutable_op();
}

inline bool ValOrOp::has_value_or_op() const {
  return value_or_op_case() != VALUE_OR_OP_NOT_SET;
}
inline void ValOrOp::clear_has_value_or_op() {
  _oneof_case_[0] = VALUE_OR_OP_NOT_SET;
}
inline ValOrOp::ValueOrOpCase ValOrOp::value_or_op_case() const {
  return ValOrOp::ValueOrOpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CodeBlock

// repeated .vyper.Statement statements = 1;
inline int CodeBlock::_internal_statements_size() const {
  return statements_.size();
}
inline int CodeBlock::statements_size() const {
  return _internal_statements_size();
}
inline void CodeBlock::clear_statements() {
  statements_.Clear();
}
inline ::vyper::Statement* CodeBlock::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.CodeBlock.statements)
  return statements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >*
CodeBlock::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:vyper.CodeBlock.statements)
  return &statements_;
}
inline const ::vyper::Statement& CodeBlock::_internal_statements(int index) const {
  return statements_.Get(index);
}
inline const ::vyper::Statement& CodeBlock::statements(int index) const {
  // @@protoc_insertion_point(field_get:vyper.CodeBlock.statements)
  return _internal_statements(index);
}
inline ::vyper::Statement* CodeBlock::_internal_add_statements() {
  return statements_.Add();
}
inline ::vyper::Statement* CodeBlock::add_statements() {
  // @@protoc_insertion_point(field_add:vyper.CodeBlock.statements)
  return _internal_add_statements();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >&
CodeBlock::statements() const {
  // @@protoc_insertion_point(field_list:vyper.CodeBlock.statements)
  return statements_;
}

// -------------------------------------------------------------------

// ArgDef

// string arg_name = 1;
inline void ArgDef::clear_arg_name() {
  arg_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ArgDef::arg_name() const {
  // @@protoc_insertion_point(field_get:vyper.ArgDef.arg_name)
  return _internal_arg_name();
}
inline void ArgDef::set_arg_name(const std::string& value) {
  _internal_set_arg_name(value);
  // @@protoc_insertion_point(field_set:vyper.ArgDef.arg_name)
}
inline std::string* ArgDef::mutable_arg_name() {
  // @@protoc_insertion_point(field_mutable:vyper.ArgDef.arg_name)
  return _internal_mutable_arg_name();
}
inline const std::string& ArgDef::_internal_arg_name() const {
  return arg_name_.Get();
}
inline void ArgDef::_internal_set_arg_name(const std::string& value) {
  
  arg_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ArgDef::set_arg_name(std::string&& value) {
  
  arg_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.ArgDef.arg_name)
}
inline void ArgDef::set_arg_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  arg_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.ArgDef.arg_name)
}
inline void ArgDef::set_arg_name(const char* value,
    size_t size) {
  
  arg_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.ArgDef.arg_name)
}
inline std::string* ArgDef::_internal_mutable_arg_name() {
  
  return arg_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ArgDef::release_arg_name() {
  // @@protoc_insertion_point(field_release:vyper.ArgDef.arg_name)
  return arg_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ArgDef::set_allocated_arg_name(std::string* arg_name) {
  if (arg_name != nullptr) {
    
  } else {
    
  }
  arg_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vyper.ArgDef.arg_name)
}
inline std::string* ArgDef::unsafe_arena_release_arg_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ArgDef.arg_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return arg_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ArgDef::unsafe_arena_set_allocated_arg_name(
    std::string* arg_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (arg_name != nullptr) {
    
  } else {
    
  }
  arg_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      arg_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ArgDef.arg_name)
}

// .vyper.Type arg_type = 2;
inline bool ArgDef::_internal_has_arg_type() const {
  return this != internal_default_instance() && arg_type_ != nullptr;
}
inline bool ArgDef::has_arg_type() const {
  return _internal_has_arg_type();
}
inline void ArgDef::clear_arg_type() {
  if (GetArena() == nullptr && arg_type_ != nullptr) {
    delete arg_type_;
  }
  arg_type_ = nullptr;
}
inline const ::vyper::Type& ArgDef::_internal_arg_type() const {
  const ::vyper::Type* p = arg_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Type*>(
      &::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& ArgDef::arg_type() const {
  // @@protoc_insertion_point(field_get:vyper.ArgDef.arg_type)
  return _internal_arg_type();
}
inline void ArgDef::unsafe_arena_set_allocated_arg_type(
    ::vyper::Type* arg_type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arg_type_);
  }
  arg_type_ = arg_type;
  if (arg_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ArgDef.arg_type)
}
inline ::vyper::Type* ArgDef::release_arg_type() {
  auto temp = unsafe_arena_release_arg_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Type* ArgDef::unsafe_arena_release_arg_type() {
  // @@protoc_insertion_point(field_release:vyper.ArgDef.arg_type)
  
  ::vyper::Type* temp = arg_type_;
  arg_type_ = nullptr;
  return temp;
}
inline ::vyper::Type* ArgDef::_internal_mutable_arg_type() {
  
  if (arg_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Type>(GetArena());
    arg_type_ = p;
  }
  return arg_type_;
}
inline ::vyper::Type* ArgDef::mutable_arg_type() {
  // @@protoc_insertion_point(field_mutable:vyper.ArgDef.arg_type)
  return _internal_mutable_arg_type();
}
inline void ArgDef::set_allocated_arg_type(::vyper::Type* arg_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete arg_type_;
  }
  if (arg_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(arg_type);
    if (message_arena != submessage_arena) {
      arg_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arg_type, submessage_arena);
    }
    
  } else {
    
  }
  arg_type_ = arg_type;
  // @@protoc_insertion_point(field_set_allocated:vyper.ArgDef.arg_type)
}

// -------------------------------------------------------------------

// FunctionDef

// string function_name = 1;
inline void FunctionDef::clear_function_name() {
  function_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FunctionDef::function_name() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.function_name)
  return _internal_function_name();
}
inline void FunctionDef::set_function_name(const std::string& value) {
  _internal_set_function_name(value);
  // @@protoc_insertion_point(field_set:vyper.FunctionDef.function_name)
}
inline std::string* FunctionDef::mutable_function_name() {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.function_name)
  return _internal_mutable_function_name();
}
inline const std::string& FunctionDef::_internal_function_name() const {
  return function_name_.Get();
}
inline void FunctionDef::_internal_set_function_name(const std::string& value) {
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FunctionDef::set_function_name(std::string&& value) {
  
  function_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.FunctionDef.function_name)
}
inline void FunctionDef::set_function_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.FunctionDef.function_name)
}
inline void FunctionDef::set_function_name(const char* value,
    size_t size) {
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.FunctionDef.function_name)
}
inline std::string* FunctionDef::_internal_mutable_function_name() {
  
  return function_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FunctionDef::release_function_name() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.function_name)
  return function_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionDef::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.function_name)
}
inline std::string* FunctionDef::unsafe_arena_release_function_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.FunctionDef.function_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return function_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FunctionDef::unsafe_arena_set_allocated_function_name(
    std::string* function_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      function_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.function_name)
}

// repeated .vyper.ArgDef args = 2;
inline int FunctionDef::_internal_args_size() const {
  return args_.size();
}
inline int FunctionDef::args_size() const {
  return _internal_args_size();
}
inline void FunctionDef::clear_args() {
  args_.Clear();
}
inline ::vyper::ArgDef* FunctionDef::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >*
FunctionDef::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.FunctionDef.args)
  return &args_;
}
inline const ::vyper::ArgDef& FunctionDef::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::vyper::ArgDef& FunctionDef::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.args)
  return _internal_args(index);
}
inline ::vyper::ArgDef* FunctionDef::_internal_add_args() {
  return args_.Add();
}
inline ::vyper::ArgDef* FunctionDef::add_args() {
  // @@protoc_insertion_point(field_add:vyper.FunctionDef.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >&
FunctionDef::args() const {
  // @@protoc_insertion_point(field_list:vyper.FunctionDef.args)
  return args_;
}

// .vyper.CodeBlock block = 3;
inline bool FunctionDef::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool FunctionDef::has_block() const {
  return _internal_has_block();
}
inline void FunctionDef::clear_block() {
  if (GetArena() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::vyper::CodeBlock& FunctionDef::_internal_block() const {
  const ::vyper::CodeBlock* p = block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::CodeBlock*>(
      &::vyper::_CodeBlock_default_instance_);
}
inline const ::vyper::CodeBlock& FunctionDef::block() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.block)
  return _internal_block();
}
inline void FunctionDef::unsafe_arena_set_allocated_block(
    ::vyper::CodeBlock* block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.block)
}
inline ::vyper::CodeBlock* FunctionDef::release_block() {
  auto temp = unsafe_arena_release_block();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::CodeBlock* FunctionDef::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.block)
  
  ::vyper::CodeBlock* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::vyper::CodeBlock* FunctionDef::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::CodeBlock>(GetArena());
    block_ = p;
  }
  return block_;
}
inline ::vyper::CodeBlock* FunctionDef::mutable_block() {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.block)
  return _internal_mutable_block();
}
inline void FunctionDef::set_allocated_block(::vyper::CodeBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.block)
}

// bool external = 4;
inline void FunctionDef::clear_external() {
  external_ = false;
}
inline bool FunctionDef::_internal_external() const {
  return external_;
}
inline bool FunctionDef::external() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.external)
  return _internal_external();
}
inline void FunctionDef::_internal_set_external(bool value) {
  
  external_ = value;
}
inline void FunctionDef::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:vyper.FunctionDef.external)
}

// .vyper.Type return_type = 5;
inline bool FunctionDef::_internal_has_return_type() const {
  return this != internal_default_instance() && return_type_ != nullptr;
}
inline bool FunctionDef::has_return_type() const {
  return _internal_has_return_type();
}
inline void FunctionDef::clear_return_type() {
  if (GetArena() == nullptr && return_type_ != nullptr) {
    delete return_type_;
  }
  return_type_ = nullptr;
}
inline const ::vyper::Type& FunctionDef::_internal_return_type() const {
  const ::vyper::Type* p = return_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Type*>(
      &::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& FunctionDef::return_type() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.return_type)
  return _internal_return_type();
}
inline void FunctionDef::unsafe_arena_set_allocated_return_type(
    ::vyper::Type* return_type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(return_type_);
  }
  return_type_ = return_type;
  if (return_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.return_type)
}
inline ::vyper::Type* FunctionDef::release_return_type() {
  auto temp = unsafe_arena_release_return_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Type* FunctionDef::unsafe_arena_release_return_type() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.return_type)
  
  ::vyper::Type* temp = return_type_;
  return_type_ = nullptr;
  return temp;
}
inline ::vyper::Type* FunctionDef::_internal_mutable_return_type() {
  
  if (return_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Type>(GetArena());
    return_type_ = p;
  }
  return return_type_;
}
inline ::vyper::Type* FunctionDef::mutable_return_type() {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.return_type)
  return _internal_mutable_return_type();
}
inline void FunctionDef::set_allocated_return_type(::vyper::Type* return_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete return_type_;
  }
  if (return_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(return_type);
    if (message_arena != submessage_arena) {
      return_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, return_type, submessage_arena);
    }
    
  } else {
    
  }
  return_type_ = return_type;
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.return_type)
}

// -------------------------------------------------------------------

// Type

// .vyper.TYPE_ENUM typeVal = 1;
inline void Type::clear_typeval() {
  typeval_ = 0;
}
inline ::vyper::TYPE_ENUM Type::_internal_typeval() const {
  return static_cast< ::vyper::TYPE_ENUM >(typeval_);
}
inline ::vyper::TYPE_ENUM Type::typeval() const {
  // @@protoc_insertion_point(field_get:vyper.Type.typeVal)
  return _internal_typeval();
}
inline void Type::_internal_set_typeval(::vyper::TYPE_ENUM value) {
  
  typeval_ = value;
}
inline void Type::set_typeval(::vyper::TYPE_ENUM value) {
  _internal_set_typeval(value);
  // @@protoc_insertion_point(field_set:vyper.Type.typeVal)
}

// -------------------------------------------------------------------

// Assignment

// string variable_name = 1;
inline void Assignment::clear_variable_name() {
  variable_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Assignment::variable_name() const {
  // @@protoc_insertion_point(field_get:vyper.Assignment.variable_name)
  return _internal_variable_name();
}
inline void Assignment::set_variable_name(const std::string& value) {
  _internal_set_variable_name(value);
  // @@protoc_insertion_point(field_set:vyper.Assignment.variable_name)
}
inline std::string* Assignment::mutable_variable_name() {
  // @@protoc_insertion_point(field_mutable:vyper.Assignment.variable_name)
  return _internal_mutable_variable_name();
}
inline const std::string& Assignment::_internal_variable_name() const {
  return variable_name_.Get();
}
inline void Assignment::_internal_set_variable_name(const std::string& value) {
  
  variable_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Assignment::set_variable_name(std::string&& value) {
  
  variable_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.Assignment.variable_name)
}
inline void Assignment::set_variable_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.Assignment.variable_name)
}
inline void Assignment::set_variable_name(const char* value,
    size_t size) {
  
  variable_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.Assignment.variable_name)
}
inline std::string* Assignment::_internal_mutable_variable_name() {
  
  return variable_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Assignment::release_variable_name() {
  // @@protoc_insertion_point(field_release:vyper.Assignment.variable_name)
  return variable_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Assignment::set_allocated_variable_name(std::string* variable_name) {
  if (variable_name != nullptr) {
    
  } else {
    
  }
  variable_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vyper.Assignment.variable_name)
}
inline std::string* Assignment::unsafe_arena_release_variable_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Assignment.variable_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return variable_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Assignment::unsafe_arena_set_allocated_variable_name(
    std::string* variable_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (variable_name != nullptr) {
    
  } else {
    
  }
  variable_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      variable_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Assignment.variable_name)
}

// .vyper.ValOrOp value = 3;
inline bool Assignment::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Assignment::has_value() const {
  return _internal_has_value();
}
inline void Assignment::clear_value() {
  if (GetArena() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::vyper::ValOrOp& Assignment::_internal_value() const {
  const ::vyper::ValOrOp* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::ValOrOp*>(
      &::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& Assignment::value() const {
  // @@protoc_insertion_point(field_get:vyper.Assignment.value)
  return _internal_value();
}
inline void Assignment::unsafe_arena_set_allocated_value(
    ::vyper::ValOrOp* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Assignment.value)
}
inline ::vyper::ValOrOp* Assignment::release_value() {
  auto temp = unsafe_arena_release_value();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::ValOrOp* Assignment::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:vyper.Assignment.value)
  
  ::vyper::ValOrOp* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::vyper::ValOrOp* Assignment::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::ValOrOp>(GetArena());
    value_ = p;
  }
  return value_;
}
inline ::vyper::ValOrOp* Assignment::mutable_value() {
  // @@protoc_insertion_point(field_mutable:vyper.Assignment.value)
  return _internal_mutable_value();
}
inline void Assignment::set_allocated_value(::vyper::ValOrOp* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:vyper.Assignment.value)
}

// -------------------------------------------------------------------

// IfStatement

// string condition = 1;
inline void IfStatement::clear_condition() {
  condition_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& IfStatement::condition() const {
  // @@protoc_insertion_point(field_get:vyper.IfStatement.condition)
  return _internal_condition();
}
inline void IfStatement::set_condition(const std::string& value) {
  _internal_set_condition(value);
  // @@protoc_insertion_point(field_set:vyper.IfStatement.condition)
}
inline std::string* IfStatement::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:vyper.IfStatement.condition)
  return _internal_mutable_condition();
}
inline const std::string& IfStatement::_internal_condition() const {
  return condition_.Get();
}
inline void IfStatement::_internal_set_condition(const std::string& value) {
  
  condition_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IfStatement::set_condition(std::string&& value) {
  
  condition_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.IfStatement.condition)
}
inline void IfStatement::set_condition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  condition_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.IfStatement.condition)
}
inline void IfStatement::set_condition(const char* value,
    size_t size) {
  
  condition_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.IfStatement.condition)
}
inline std::string* IfStatement::_internal_mutable_condition() {
  
  return condition_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IfStatement::release_condition() {
  // @@protoc_insertion_point(field_release:vyper.IfStatement.condition)
  return condition_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IfStatement::set_allocated_condition(std::string* condition) {
  if (condition != nullptr) {
    
  } else {
    
  }
  condition_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), condition,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vyper.IfStatement.condition)
}
inline std::string* IfStatement::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.IfStatement.condition)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return condition_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void IfStatement::unsafe_arena_set_allocated_condition(
    std::string* condition) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (condition != nullptr) {
    
  } else {
    
  }
  condition_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      condition, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.IfStatement.condition)
}

// .vyper.CodeBlock block = 2;
inline bool IfStatement::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool IfStatement::has_block() const {
  return _internal_has_block();
}
inline void IfStatement::clear_block() {
  if (GetArena() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::vyper::CodeBlock& IfStatement::_internal_block() const {
  const ::vyper::CodeBlock* p = block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::CodeBlock*>(
      &::vyper::_CodeBlock_default_instance_);
}
inline const ::vyper::CodeBlock& IfStatement::block() const {
  // @@protoc_insertion_point(field_get:vyper.IfStatement.block)
  return _internal_block();
}
inline void IfStatement::unsafe_arena_set_allocated_block(
    ::vyper::CodeBlock* block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.IfStatement.block)
}
inline ::vyper::CodeBlock* IfStatement::release_block() {
  auto temp = unsafe_arena_release_block();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::CodeBlock* IfStatement::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:vyper.IfStatement.block)
  
  ::vyper::CodeBlock* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::vyper::CodeBlock* IfStatement::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::CodeBlock>(GetArena());
    block_ = p;
  }
  return block_;
}
inline ::vyper::CodeBlock* IfStatement::mutable_block() {
  // @@protoc_insertion_point(field_mutable:vyper.IfStatement.block)
  return _internal_mutable_block();
}
inline void IfStatement::set_allocated_block(::vyper::CodeBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:vyper.IfStatement.block)
}

// -------------------------------------------------------------------

// FunctionCall

// string function_name = 1;
inline void FunctionCall::clear_function_name() {
  function_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FunctionCall::function_name() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionCall.function_name)
  return _internal_function_name();
}
inline void FunctionCall::set_function_name(const std::string& value) {
  _internal_set_function_name(value);
  // @@protoc_insertion_point(field_set:vyper.FunctionCall.function_name)
}
inline std::string* FunctionCall::mutable_function_name() {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionCall.function_name)
  return _internal_mutable_function_name();
}
inline const std::string& FunctionCall::_internal_function_name() const {
  return function_name_.Get();
}
inline void FunctionCall::_internal_set_function_name(const std::string& value) {
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FunctionCall::set_function_name(std::string&& value) {
  
  function_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vyper.FunctionCall.function_name)
}
inline void FunctionCall::set_function_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:vyper.FunctionCall.function_name)
}
inline void FunctionCall::set_function_name(const char* value,
    size_t size) {
  
  function_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vyper.FunctionCall.function_name)
}
inline std::string* FunctionCall::_internal_mutable_function_name() {
  
  return function_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FunctionCall::release_function_name() {
  // @@protoc_insertion_point(field_release:vyper.FunctionCall.function_name)
  return function_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCall::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionCall.function_name)
}
inline std::string* FunctionCall::unsafe_arena_release_function_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.FunctionCall.function_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return function_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FunctionCall::unsafe_arena_set_allocated_function_name(
    std::string* function_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      function_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionCall.function_name)
}

// repeated .vyper.ValOrOp args = 3;
inline int FunctionCall::_internal_args_size() const {
  return args_.size();
}
inline int FunctionCall::args_size() const {
  return _internal_args_size();
}
inline void FunctionCall::clear_args() {
  args_.Clear();
}
inline ::vyper::ValOrOp* FunctionCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionCall.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >*
FunctionCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.FunctionCall.args)
  return &args_;
}
inline const ::vyper::ValOrOp& FunctionCall::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::vyper::ValOrOp& FunctionCall::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.FunctionCall.args)
  return _internal_args(index);
}
inline ::vyper::ValOrOp* FunctionCall::_internal_add_args() {
  return args_.Add();
}
inline ::vyper::ValOrOp* FunctionCall::add_args() {
  // @@protoc_insertion_point(field_add:vyper.FunctionCall.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >&
FunctionCall::args() const {
  // @@protoc_insertion_point(field_list:vyper.FunctionCall.args)
  return args_;
}

// -------------------------------------------------------------------

// ConcatCall

// repeated string args = 1;
inline int ConcatCall::_internal_args_size() const {
  return args_.size();
}
inline int ConcatCall::args_size() const {
  return _internal_args_size();
}
inline void ConcatCall::clear_args() {
  args_.Clear();
}
inline std::string* ConcatCall::add_args() {
  // @@protoc_insertion_point(field_add_mutable:vyper.ConcatCall.args)
  return _internal_add_args();
}
inline const std::string& ConcatCall::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& ConcatCall::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.ConcatCall.args)
  return _internal_args(index);
}
inline std::string* ConcatCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.ConcatCall.args)
  return args_.Mutable(index);
}
inline void ConcatCall::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vyper.ConcatCall.args)
  args_.Mutable(index)->assign(value);
}
inline void ConcatCall::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vyper.ConcatCall.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void ConcatCall::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vyper.ConcatCall.args)
}
inline void ConcatCall::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vyper.ConcatCall.args)
}
inline std::string* ConcatCall::_internal_add_args() {
  return args_.Add();
}
inline void ConcatCall::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vyper.ConcatCall.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConcatCall::args() const {
  // @@protoc_insertion_point(field_list:vyper.ConcatCall.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConcatCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.ConcatCall.args)
  return &args_;
}

// -------------------------------------------------------------------

// ConvertCall

// .vyper.ValOrOp value = 1;
inline bool ConvertCall::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool ConvertCall::has_value() const {
  return _internal_has_value();
}
inline void ConvertCall::clear_value() {
  if (GetArena() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::vyper::ValOrOp& ConvertCall::_internal_value() const {
  const ::vyper::ValOrOp* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::ValOrOp*>(
      &::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& ConvertCall::value() const {
  // @@protoc_insertion_point(field_get:vyper.ConvertCall.value)
  return _internal_value();
}
inline void ConvertCall::unsafe_arena_set_allocated_value(
    ::vyper::ValOrOp* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ConvertCall.value)
}
inline ::vyper::ValOrOp* ConvertCall::release_value() {
  auto temp = unsafe_arena_release_value();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::ValOrOp* ConvertCall::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:vyper.ConvertCall.value)
  
  ::vyper::ValOrOp* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::vyper::ValOrOp* ConvertCall::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::ValOrOp>(GetArena());
    value_ = p;
  }
  return value_;
}
inline ::vyper::ValOrOp* ConvertCall::mutable_value() {
  // @@protoc_insertion_point(field_mutable:vyper.ConvertCall.value)
  return _internal_mutable_value();
}
inline void ConvertCall::set_allocated_value(::vyper::ValOrOp* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:vyper.ConvertCall.value)
}

// .vyper.Type type = 2;
inline bool ConvertCall::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool ConvertCall::has_type() const {
  return _internal_has_type();
}
inline void ConvertCall::clear_type() {
  if (GetArena() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::vyper::Type& ConvertCall::_internal_type() const {
  const ::vyper::Type* p = type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vyper::Type*>(
      &::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& ConvertCall::type() const {
  // @@protoc_insertion_point(field_get:vyper.ConvertCall.type)
  return _internal_type();
}
inline void ConvertCall::unsafe_arena_set_allocated_type(
    ::vyper::Type* type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ConvertCall.type)
}
inline ::vyper::Type* ConvertCall::release_type() {
  auto temp = unsafe_arena_release_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vyper::Type* ConvertCall::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:vyper.ConvertCall.type)
  
  ::vyper::Type* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::vyper::Type* ConvertCall::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Type>(GetArena());
    type_ = p;
  }
  return type_;
}
inline ::vyper::Type* ConvertCall::mutable_type() {
  // @@protoc_insertion_point(field_mutable:vyper.ConvertCall.type)
  return _internal_mutable_type();
}
inline void ConvertCall::set_allocated_type(::vyper::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:vyper.ConvertCall.type)
}

// -------------------------------------------------------------------

// BuiltinCall

// .vyper.ConcatCall concat = 1;
inline bool BuiltinCall::_internal_has_concat() const {
  return call_case() == kConcat;
}
inline bool BuiltinCall::has_concat() const {
  return _internal_has_concat();
}
inline void BuiltinCall::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void BuiltinCall::clear_concat() {
  if (_internal_has_concat()) {
    if (GetArena() == nullptr) {
      delete call_.concat_;
    }
    clear_has_call();
  }
}
inline ::vyper::ConcatCall* BuiltinCall::release_concat() {
  // @@protoc_insertion_point(field_release:vyper.BuiltinCall.concat)
  if (_internal_has_concat()) {
    clear_has_call();
      ::vyper::ConcatCall* temp = call_.concat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    call_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::ConcatCall& BuiltinCall::_internal_concat() const {
  return _internal_has_concat()
      ? *call_.concat_
      : *reinterpret_cast< ::vyper::ConcatCall*>(&::vyper::_ConcatCall_default_instance_);
}
inline const ::vyper::ConcatCall& BuiltinCall::concat() const {
  // @@protoc_insertion_point(field_get:vyper.BuiltinCall.concat)
  return _internal_concat();
}
inline ::vyper::ConcatCall* BuiltinCall::unsafe_arena_release_concat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.BuiltinCall.concat)
  if (_internal_has_concat()) {
    clear_has_call();
    ::vyper::ConcatCall* temp = call_.concat_;
    call_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinCall::unsafe_arena_set_allocated_concat(::vyper::ConcatCall* concat) {
  clear_call();
  if (concat) {
    set_has_concat();
    call_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.BuiltinCall.concat)
}
inline ::vyper::ConcatCall* BuiltinCall::_internal_mutable_concat() {
  if (!_internal_has_concat()) {
    clear_call();
    set_has_concat();
    call_.concat_ = CreateMaybeMessage< ::vyper::ConcatCall >(GetArena());
  }
  return call_.concat_;
}
inline ::vyper::ConcatCall* BuiltinCall::mutable_concat() {
  // @@protoc_insertion_point(field_mutable:vyper.BuiltinCall.concat)
  return _internal_mutable_concat();
}

// .vyper.ConvertCall convert = 2;
inline bool BuiltinCall::_internal_has_convert() const {
  return call_case() == kConvert;
}
inline bool BuiltinCall::has_convert() const {
  return _internal_has_convert();
}
inline void BuiltinCall::set_has_convert() {
  _oneof_case_[0] = kConvert;
}
inline void BuiltinCall::clear_convert() {
  if (_internal_has_convert()) {
    if (GetArena() == nullptr) {
      delete call_.convert_;
    }
    clear_has_call();
  }
}
inline ::vyper::ConvertCall* BuiltinCall::release_convert() {
  // @@protoc_insertion_point(field_release:vyper.BuiltinCall.convert)
  if (_internal_has_convert()) {
    clear_has_call();
      ::vyper::ConvertCall* temp = call_.convert_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    call_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::ConvertCall& BuiltinCall::_internal_convert() const {
  return _internal_has_convert()
      ? *call_.convert_
      : *reinterpret_cast< ::vyper::ConvertCall*>(&::vyper::_ConvertCall_default_instance_);
}
inline const ::vyper::ConvertCall& BuiltinCall::convert() const {
  // @@protoc_insertion_point(field_get:vyper.BuiltinCall.convert)
  return _internal_convert();
}
inline ::vyper::ConvertCall* BuiltinCall::unsafe_arena_release_convert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.BuiltinCall.convert)
  if (_internal_has_convert()) {
    clear_has_call();
    ::vyper::ConvertCall* temp = call_.convert_;
    call_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinCall::unsafe_arena_set_allocated_convert(::vyper::ConvertCall* convert) {
  clear_call();
  if (convert) {
    set_has_convert();
    call_.convert_ = convert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.BuiltinCall.convert)
}
inline ::vyper::ConvertCall* BuiltinCall::_internal_mutable_convert() {
  if (!_internal_has_convert()) {
    clear_call();
    set_has_convert();
    call_.convert_ = CreateMaybeMessage< ::vyper::ConvertCall >(GetArena());
  }
  return call_.convert_;
}
inline ::vyper::ConvertCall* BuiltinCall::mutable_convert() {
  // @@protoc_insertion_point(field_mutable:vyper.BuiltinCall.convert)
  return _internal_mutable_convert();
}

inline bool BuiltinCall::has_call() const {
  return call_case() != CALL_NOT_SET;
}
inline void BuiltinCall::clear_has_call() {
  _oneof_case_[0] = CALL_NOT_SET;
}
inline BuiltinCall::CallCase BuiltinCall::call_case() const {
  return BuiltinCall::CallCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VyperContract

// repeated .vyper.FunctionDef functions = 1;
inline int VyperContract::_internal_functions_size() const {
  return functions_.size();
}
inline int VyperContract::functions_size() const {
  return _internal_functions_size();
}
inline void VyperContract::clear_functions() {
  functions_.Clear();
}
inline ::vyper::FunctionDef* VyperContract::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.VyperContract.functions)
  return functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >*
VyperContract::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:vyper.VyperContract.functions)
  return &functions_;
}
inline const ::vyper::FunctionDef& VyperContract::_internal_functions(int index) const {
  return functions_.Get(index);
}
inline const ::vyper::FunctionDef& VyperContract::functions(int index) const {
  // @@protoc_insertion_point(field_get:vyper.VyperContract.functions)
  return _internal_functions(index);
}
inline ::vyper::FunctionDef* VyperContract::_internal_add_functions() {
  return functions_.Add();
}
inline ::vyper::FunctionDef* VyperContract::add_functions() {
  // @@protoc_insertion_point(field_add:vyper.VyperContract.functions)
  return _internal_add_functions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >&
VyperContract::functions() const {
  // @@protoc_insertion_point(field_list:vyper.VyperContract.functions)
  return functions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vyper

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vyper::Operator_OPERATOR> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vyper::Operator_OPERATOR>() {
  return ::vyper::Operator_OPERATOR_descriptor();
}
template <> struct is_proto_enum< ::vyper::TYPE_ENUM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vyper::TYPE_ENUM>() {
  return ::vyper::TYPE_ENUM_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto
