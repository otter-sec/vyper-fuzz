// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vyper.proto

#include "vyper.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace vyper {
PROTOBUF_CONSTEXPR Statement::Statement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.statement_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StatementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatementDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatementDefaultTypeInternal() {}
  union {
    Statement _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatementDefaultTypeInternal _Statement_default_instance_;
PROTOBUF_CONSTEXPR Uint256::Uint256(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hb_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lb_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Uint256DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Uint256DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Uint256DefaultTypeInternal() {}
  union {
    Uint256 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Uint256DefaultTypeInternal _Uint256_default_instance_;
PROTOBUF_CONSTEXPR Value::Value(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueDefaultTypeInternal() {}
  union {
    Value _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueDefaultTypeInternal _Value_default_instance_;
PROTOBUF_CONSTEXPR Operator::Operator(
    ::_pbi::ConstantInitialized) {}
struct OperatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperatorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperatorDefaultTypeInternal() {}
  union {
    Operator _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperatorDefaultTypeInternal _Operator_default_instance_;
PROTOBUF_CONSTEXPR Operation::Operation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val1_)*/nullptr
  , /*decltype(_impl_.val2_)*/nullptr
  , /*decltype(_impl_.operator__)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDefaultTypeInternal() {}
  union {
    Operation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDefaultTypeInternal _Operation_default_instance_;
PROTOBUF_CONSTEXPR VarDecl::VarDecl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.var_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VarDeclDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarDeclDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarDeclDefaultTypeInternal() {}
  union {
    VarDecl _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarDeclDefaultTypeInternal _VarDecl_default_instance_;
PROTOBUF_CONSTEXPR ValOrOp::ValOrOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_or_op_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ValOrOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValOrOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValOrOpDefaultTypeInternal() {}
  union {
    ValOrOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValOrOpDefaultTypeInternal _ValOrOp_default_instance_;
PROTOBUF_CONSTEXPR CodeBlock::CodeBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.statements_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CodeBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CodeBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CodeBlockDefaultTypeInternal() {}
  union {
    CodeBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CodeBlockDefaultTypeInternal _CodeBlock_default_instance_;
PROTOBUF_CONSTEXPR ArgDef::ArgDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.arg_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.arg_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ArgDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArgDefDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArgDefDefaultTypeInternal() {}
  union {
    ArgDef _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArgDefDefaultTypeInternal _ArgDef_default_instance_;
PROTOBUF_CONSTEXPR FunctionDef::FunctionDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.function_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_.external_)*/ false

  , /*decltype(_impl_.ret_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FunctionDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FunctionDefDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FunctionDefDefaultTypeInternal() {}
  union {
    FunctionDef _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FunctionDefDefaultTypeInternal _FunctionDef_default_instance_;
PROTOBUF_CONSTEXPR Type::Type(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.typeval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypeDefaultTypeInternal() {}
  union {
    Type _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypeDefaultTypeInternal _Type_default_instance_;
PROTOBUF_CONSTEXPR SizedType::SizedType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.typeval_)*/ 0

  , /*decltype(_impl_.size_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SizedTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SizedTypeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SizedTypeDefaultTypeInternal() {}
  union {
    SizedType _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SizedTypeDefaultTypeInternal _SizedType_default_instance_;
PROTOBUF_CONSTEXPR Assignment::Assignment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.var_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssignmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssignmentDefaultTypeInternal() {}
  union {
    Assignment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssignmentDefaultTypeInternal _Assignment_default_instance_;
PROTOBUF_CONSTEXPR IfStatement::IfStatement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.condition_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IfStatementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IfStatementDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IfStatementDefaultTypeInternal() {}
  union {
    IfStatement _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IfStatementDefaultTypeInternal _IfStatement_default_instance_;
PROTOBUF_CONSTEXPR FunctionCall::FunctionCall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.function_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.self_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FunctionCallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FunctionCallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FunctionCallDefaultTypeInternal() {}
  union {
    FunctionCall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
PROTOBUF_CONSTEXPR ConcatCall::ConcatCall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConcatCallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConcatCallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConcatCallDefaultTypeInternal() {}
  union {
    ConcatCall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConcatCallDefaultTypeInternal _ConcatCall_default_instance_;
PROTOBUF_CONSTEXPR ConvertCall::ConvertCall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.type_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConvertCallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConvertCallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConvertCallDefaultTypeInternal() {}
  union {
    ConvertCall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConvertCallDefaultTypeInternal _ConvertCall_default_instance_;
PROTOBUF_CONSTEXPR BuiltinCall::BuiltinCall(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.call_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BuiltinCallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuiltinCallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuiltinCallDefaultTypeInternal() {}
  union {
    BuiltinCall _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuiltinCallDefaultTypeInternal _BuiltinCall_default_instance_;
PROTOBUF_CONSTEXPR VyperContract::VyperContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.functions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VyperContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VyperContractDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VyperContractDefaultTypeInternal() {}
  union {
    VyperContract _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VyperContractDefaultTypeInternal _VyperContract_default_instance_;
}  // namespace vyper
static ::_pb::Metadata file_level_metadata_vyper_2eproto[19];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_vyper_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_vyper_2eproto = nullptr;
const ::uint32_t TableStruct_vyper_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Statement, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::Statement, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::Statement, _impl_.statement_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Uint256, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::Uint256, _impl_.hb_),
    PROTOBUF_FIELD_OFFSET(::vyper::Uint256, _impl_.lb_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Value, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::Value, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::Value, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Operator, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Operation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::Operation, _impl_.val1_),
    PROTOBUF_FIELD_OFFSET(::vyper::Operation, _impl_.val2_),
    PROTOBUF_FIELD_OFFSET(::vyper::Operation, _impl_.operator__),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::VarDecl, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::VarDecl, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::VarDecl, _impl_.var_name_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::VarDecl, _impl_._type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::ValOrOp, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::ValOrOp, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::ValOrOp, _impl_.value_or_op_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::CodeBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::CodeBlock, _impl_.statements_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::ArgDef, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::ArgDef, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::ArgDef, _impl_.arg_name_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::ArgDef, _impl_.arg_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_.function_name_),
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_.args_),
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_.block_),
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_.external_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_.ret_type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Type, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::Type, _impl_.typeval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::SizedType, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::SizedType, _impl_.typeval_),
    PROTOBUF_FIELD_OFFSET(::vyper::SizedType, _impl_.size_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::Assignment, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::Assignment, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::Assignment, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::vyper::Assignment, _impl_.var_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::IfStatement, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::IfStatement, _impl_.condition_),
    PROTOBUF_FIELD_OFFSET(::vyper::IfStatement, _impl_.block_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionCall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionCall, _impl_.function_name_),
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionCall, _impl_.args_),
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionCall, _impl_.self_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::ConcatCall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::ConcatCall, _impl_.args_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::ConvertCall, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::ConvertCall, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::vyper::ConvertCall, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::BuiltinCall, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::vyper::BuiltinCall, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::vyper::BuiltinCall, _impl_.call_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::vyper::VyperContract, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::vyper::VyperContract, _impl_.functions_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::vyper::Statement)},
        { 15, -1, -1, sizeof(::vyper::Uint256)},
        { 25, -1, -1, sizeof(::vyper::Value)},
        { 37, -1, -1, sizeof(::vyper::Operator)},
        { 45, -1, -1, sizeof(::vyper::Operation)},
        { 56, -1, -1, sizeof(::vyper::VarDecl)},
        { 68, -1, -1, sizeof(::vyper::ValOrOp)},
        { 81, -1, -1, sizeof(::vyper::CodeBlock)},
        { 90, -1, -1, sizeof(::vyper::ArgDef)},
        { 102, -1, -1, sizeof(::vyper::FunctionDef)},
        { 117, -1, -1, sizeof(::vyper::Type)},
        { 126, -1, -1, sizeof(::vyper::SizedType)},
        { 136, -1, -1, sizeof(::vyper::Assignment)},
        { 148, -1, -1, sizeof(::vyper::IfStatement)},
        { 158, -1, -1, sizeof(::vyper::FunctionCall)},
        { 169, -1, -1, sizeof(::vyper::ConcatCall)},
        { 178, -1, -1, sizeof(::vyper::ConvertCall)},
        { 188, -1, -1, sizeof(::vyper::BuiltinCall)},
        { 199, -1, -1, sizeof(::vyper::VyperContract)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::vyper::_Statement_default_instance_._instance,
    &::vyper::_Uint256_default_instance_._instance,
    &::vyper::_Value_default_instance_._instance,
    &::vyper::_Operator_default_instance_._instance,
    &::vyper::_Operation_default_instance_._instance,
    &::vyper::_VarDecl_default_instance_._instance,
    &::vyper::_ValOrOp_default_instance_._instance,
    &::vyper::_CodeBlock_default_instance_._instance,
    &::vyper::_ArgDef_default_instance_._instance,
    &::vyper::_FunctionDef_default_instance_._instance,
    &::vyper::_Type_default_instance_._instance,
    &::vyper::_SizedType_default_instance_._instance,
    &::vyper::_Assignment_default_instance_._instance,
    &::vyper::_IfStatement_default_instance_._instance,
    &::vyper::_FunctionCall_default_instance_._instance,
    &::vyper::_ConcatCall_default_instance_._instance,
    &::vyper::_ConvertCall_default_instance_._instance,
    &::vyper::_BuiltinCall_default_instance_._instance,
    &::vyper::_VyperContract_default_instance_._instance,
};
const char descriptor_table_protodef_vyper_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\013vyper.proto\022\005vyper\"\211\002\n\tStatement\022\'\n\nas"
    "signment\030\001 \001(\0132\021.vyper.AssignmentH\000\022*\n\014i"
    "f_statement\030\002 \001(\0132\022.vyper.IfStatementH\000\022"
    ",\n\rfunction_call\030\003 \001(\0132\023.vyper.FunctionC"
    "allH\000\022*\n\014builtin_call\030\004 \001(\0132\022.vyper.Buil"
    "tinCallH\000\022\036\n\004decl\030\005 \001(\0132\016.vyper.VarDeclH"
    "\000\022 \n\006return\030\006 \001(\0132\016.vyper.ValOrOpH\000B\013\n\ts"
    "tatement\"!\n\007Uint256\022\n\n\002hb\030\001 \001(\004\022\n\n\002lb\030\002 "
    "\001(\004\"Z\n\005Value\022\025\n\013str_literal\030\001 \001(\tH\000\022\022\n\010v"
    "ar_name\030\002 \001(\tH\000\022\035\n\003num\030\003 \001(\0132\016.vyper.Uin"
    "t256H\000B\007\n\005value\"\?\n\010Operator\"3\n\010OPERATOR\022"
    "\010\n\004PLUS\020\000\022\t\n\005MINUS\020\001\022\t\n\005TIMES\020\002\022\007\n\003MOD\020\003"
    "\"f\n\tOperation\022\032\n\004val1\030\001 \001(\0132\014.vyper.Valu"
    "e\022\032\n\004val2\030\002 \001(\0132\014.vyper.Value\022!\n\010operato"
    "r\030\003 \001(\0132\017.vyper.Operator\"d\n\007VarDecl\022\020\n\010v"
    "ar_name\030\001 \001(\t\022\033\n\004type\030\002 \001(\0132\013.vyper.Type"
    "H\000\022!\n\005stype\030\003 \001(\0132\020.vyper.SizedTypeH\000B\007\n"
    "\005_type\"\253\001\n\007ValOrOp\022\033\n\003val\030\001 \001(\0132\014.vyper."
    "ValueH\000\022\036\n\002op\030\002 \001(\0132\020.vyper.OperationH\000\022"
    "(\n\tfunc_call\030\003 \001(\0132\023.vyper.FunctionCallH"
    "\000\022*\n\014builtin_call\030\004 \001(\0132\022.vyper.BuiltinC"
    "allH\000B\r\n\013value_or_op\"1\n\tCodeBlock\022$\n\nsta"
    "tements\030\001 \003(\0132\020.vyper.Statement\"a\n\006ArgDe"
    "f\022\020\n\010arg_name\030\003 \001(\t\022!\n\005stype\030\001 \001(\0132\020.vyp"
    "er.SizedTypeH\000\022\033\n\004type\030\002 \001(\0132\013.vyper.Typ"
    "eH\000B\005\n\003arg\"\316\001\n\013FunctionDef\022\025\n\rfunction_n"
    "ame\030\001 \001(\t\022\033\n\004args\030\002 \003(\0132\r.vyper.ArgDef\022\037"
    "\n\005block\030\003 \001(\0132\020.vyper.CodeBlock\022\020\n\010exter"
    "nal\030\004 \001(\010\022\"\n\013return_type\030\005 \001(\0132\013.vyper.T"
    "ypeH\000\022(\n\014return_stype\030\006 \001(\0132\020.vyper.Size"
    "dTypeH\000B\n\n\010ret_type\")\n\004Type\022!\n\007typeVal\030\001"
    " \001(\0162\020.vyper.TYPE_ENUM\"B\n\tSizedType\022\'\n\007t"
    "ypeVal\030\001 \001(\0162\026.vyper.SIZED_TYPE_ENUM\022\014\n\004"
    "size\030\002 \001(\r\"k\n\nAssignment\022\027\n\rvariable_nam"
    "e\030\001 \001(\tH\000\022\036\n\004decl\030\002 \001(\0132\016.vyper.VarDeclH"
    "\000\022\035\n\005value\030\003 \001(\0132\016.vyper.ValOrOpB\005\n\003var\""
    "A\n\013IfStatement\022\021\n\tcondition\030\001 \001(\t\022\037\n\005blo"
    "ck\030\002 \001(\0132\020.vyper.CodeBlock\"Q\n\014FunctionCa"
    "ll\022\025\n\rfunction_name\030\001 \001(\t\022\034\n\004args\030\002 \003(\0132"
    "\016.vyper.ValOrOp\022\014\n\004self\030\003 \001(\010\"\032\n\nConcatC"
    "all\022\014\n\004args\030\001 \003(\t\"G\n\013ConvertCall\022\035\n\005valu"
    "e\030\001 \001(\0132\016.vyper.ValOrOp\022\031\n\004type\030\002 \001(\0132\013."
    "vyper.Type\"a\n\013BuiltinCall\022#\n\006concat\030\001 \001("
    "\0132\021.vyper.ConcatCallH\000\022%\n\007convert\030\002 \001(\0132"
    "\022.vyper.ConvertCallH\000B\006\n\004call\"6\n\rVyperCo"
    "ntract\022%\n\tfunctions\030\001 \003(\0132\022.vyper.Functi"
    "onDef*<\n\tTYPE_ENUM\022\013\n\007uint256\020\000\022\n\n\006int25"
    "6\020\001\022\t\n\005int64\020\002\022\013\n\007bytes32\020\003*\035\n\017SIZED_TYP"
    "E_ENUM\022\n\n\006String\020\000b\006proto3"
};
static ::absl::once_flag descriptor_table_vyper_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_vyper_2eproto = {
    false,
    false,
    1946,
    descriptor_table_protodef_vyper_2eproto,
    "vyper.proto",
    &descriptor_table_vyper_2eproto_once,
    nullptr,
    0,
    19,
    schemas,
    file_default_instances,
    TableStruct_vyper_2eproto::offsets,
    file_level_metadata_vyper_2eproto,
    file_level_enum_descriptors_vyper_2eproto,
    file_level_service_descriptors_vyper_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_vyper_2eproto_getter() {
  return &descriptor_table_vyper_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_vyper_2eproto(&descriptor_table_vyper_2eproto);
namespace vyper {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operator_OPERATOR_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_vyper_2eproto);
  return file_level_enum_descriptors_vyper_2eproto[0];
}
bool Operator_OPERATOR_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Operator_OPERATOR Operator::PLUS;
constexpr Operator_OPERATOR Operator::MINUS;
constexpr Operator_OPERATOR Operator::TIMES;
constexpr Operator_OPERATOR Operator::MOD;
constexpr Operator_OPERATOR Operator::OPERATOR_MIN;
constexpr Operator_OPERATOR Operator::OPERATOR_MAX;
constexpr int Operator::OPERATOR_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TYPE_ENUM_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_vyper_2eproto);
  return file_level_enum_descriptors_vyper_2eproto[1];
}
bool TYPE_ENUM_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SIZED_TYPE_ENUM_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_vyper_2eproto);
  return file_level_enum_descriptors_vyper_2eproto[2];
}
bool SIZED_TYPE_ENUM_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Statement::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::Statement, _impl_._oneof_case_);
  static const ::vyper::Assignment& assignment(const Statement* msg);
  static const ::vyper::IfStatement& if_statement(const Statement* msg);
  static const ::vyper::FunctionCall& function_call(const Statement* msg);
  static const ::vyper::BuiltinCall& builtin_call(const Statement* msg);
  static const ::vyper::VarDecl& decl(const Statement* msg);
  static const ::vyper::ValOrOp& return_(const Statement* msg);
};

const ::vyper::Assignment&
Statement::_Internal::assignment(const Statement* msg) {
  return *msg->_impl_.statement_.assignment_;
}
const ::vyper::IfStatement&
Statement::_Internal::if_statement(const Statement* msg) {
  return *msg->_impl_.statement_.if_statement_;
}
const ::vyper::FunctionCall&
Statement::_Internal::function_call(const Statement* msg) {
  return *msg->_impl_.statement_.function_call_;
}
const ::vyper::BuiltinCall&
Statement::_Internal::builtin_call(const Statement* msg) {
  return *msg->_impl_.statement_.builtin_call_;
}
const ::vyper::VarDecl&
Statement::_Internal::decl(const Statement* msg) {
  return *msg->_impl_.statement_.decl_;
}
const ::vyper::ValOrOp&
Statement::_Internal::return_(const Statement* msg) {
  return *msg->_impl_.statement_.return__;
}
void Statement::set_allocated_assignment(::vyper::Assignment* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(assignment);
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    set_has_assignment();
    _impl_.statement_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.assignment)
}
void Statement::set_allocated_if_statement(::vyper::IfStatement* if_statement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (if_statement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(if_statement);
    if (message_arena != submessage_arena) {
      if_statement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_statement, submessage_arena);
    }
    set_has_if_statement();
    _impl_.statement_.if_statement_ = if_statement;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.if_statement)
}
void Statement::set_allocated_function_call(::vyper::FunctionCall* function_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (function_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function_call);
    if (message_arena != submessage_arena) {
      function_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_call, submessage_arena);
    }
    set_has_function_call();
    _impl_.statement_.function_call_ = function_call;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.function_call)
}
void Statement::set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (builtin_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(builtin_call);
    if (message_arena != submessage_arena) {
      builtin_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, builtin_call, submessage_arena);
    }
    set_has_builtin_call();
    _impl_.statement_.builtin_call_ = builtin_call;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.builtin_call)
}
void Statement::set_allocated_decl(::vyper::VarDecl* decl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (decl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decl);
    if (message_arena != submessage_arena) {
      decl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decl, submessage_arena);
    }
    set_has_decl();
    _impl_.statement_.decl_ = decl;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.decl)
}
void Statement::set_allocated_return_(::vyper::ValOrOp* return_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_statement();
  if (return_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(return_);
    if (message_arena != submessage_arena) {
      return_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, return_, submessage_arena);
    }
    set_has_return_();
    _impl_.statement_.return__ = return_;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Statement.return)
}
Statement::Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Statement)
}
Statement::Statement(const Statement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Statement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.statement_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_statement();
  switch (from.statement_case()) {
    case kAssignment: {
      _this->_internal_mutable_assignment()->::vyper::Assignment::MergeFrom(
          from._internal_assignment());
      break;
    }
    case kIfStatement: {
      _this->_internal_mutable_if_statement()->::vyper::IfStatement::MergeFrom(
          from._internal_if_statement());
      break;
    }
    case kFunctionCall: {
      _this->_internal_mutable_function_call()->::vyper::FunctionCall::MergeFrom(
          from._internal_function_call());
      break;
    }
    case kBuiltinCall: {
      _this->_internal_mutable_builtin_call()->::vyper::BuiltinCall::MergeFrom(
          from._internal_builtin_call());
      break;
    }
    case kDecl: {
      _this->_internal_mutable_decl()->::vyper::VarDecl::MergeFrom(
          from._internal_decl());
      break;
    }
    case kReturn: {
      _this->_internal_mutable_return_()->::vyper::ValOrOp::MergeFrom(
          from._internal_return_());
      break;
    }
    case STATEMENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.Statement)
}

inline void Statement::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.statement_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_statement();
}

Statement::~Statement() {
  // @@protoc_insertion_point(destructor:vyper.Statement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Statement::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_statement()) {
    clear_statement();
  }
}

void Statement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Statement::clear_statement() {
// @@protoc_insertion_point(one_of_clear_start:vyper.Statement)
  switch (statement_case()) {
    case kAssignment: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.assignment_;
      }
      break;
    }
    case kIfStatement: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.if_statement_;
      }
      break;
    }
    case kFunctionCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.function_call_;
      }
      break;
    }
    case kBuiltinCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.builtin_call_;
      }
      break;
    }
    case kDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.decl_;
      }
      break;
    }
    case kReturn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.statement_.return__;
      }
      break;
    }
    case STATEMENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STATEMENT_NOT_SET;
}


void Statement::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Statement)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_statement();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.Assignment assignment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_assignment(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.IfStatement if_statement = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_if_statement(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.FunctionCall function_call = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_function_call(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.BuiltinCall builtin_call = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_builtin_call(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.VarDecl decl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_decl(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.ValOrOp return = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_return_(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Statement::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Statement)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.Assignment assignment = 1;
  if (statement_case() == kAssignment) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::assignment(this),
        _Internal::assignment(this).GetCachedSize(), target, stream);
  }

  // .vyper.IfStatement if_statement = 2;
  if (statement_case() == kIfStatement) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::if_statement(this),
        _Internal::if_statement(this).GetCachedSize(), target, stream);
  }

  // .vyper.FunctionCall function_call = 3;
  if (statement_case() == kFunctionCall) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::function_call(this),
        _Internal::function_call(this).GetCachedSize(), target, stream);
  }

  // .vyper.BuiltinCall builtin_call = 4;
  if (statement_case() == kBuiltinCall) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::builtin_call(this),
        _Internal::builtin_call(this).GetCachedSize(), target, stream);
  }

  // .vyper.VarDecl decl = 5;
  if (statement_case() == kDecl) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::decl(this),
        _Internal::decl(this).GetCachedSize(), target, stream);
  }

  // .vyper.ValOrOp return = 6;
  if (statement_case() == kReturn) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::return_(this),
        _Internal::return_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Statement)
  return target;
}

::size_t Statement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Statement)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (statement_case()) {
    // .vyper.Assignment assignment = 1;
    case kAssignment: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.assignment_);
      break;
    }
    // .vyper.IfStatement if_statement = 2;
    case kIfStatement: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.if_statement_);
      break;
    }
    // .vyper.FunctionCall function_call = 3;
    case kFunctionCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.function_call_);
      break;
    }
    // .vyper.BuiltinCall builtin_call = 4;
    case kBuiltinCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.builtin_call_);
      break;
    }
    // .vyper.VarDecl decl = 5;
    case kDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.decl_);
      break;
    }
    // .vyper.ValOrOp return = 6;
    case kReturn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.statement_.return__);
      break;
    }
    case STATEMENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Statement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statement::GetClassData() const { return &_class_data_; }


void Statement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Statement*>(&to_msg);
  auto& from = static_cast<const Statement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Statement)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.statement_case()) {
    case kAssignment: {
      _this->_internal_mutable_assignment()->::vyper::Assignment::MergeFrom(
          from._internal_assignment());
      break;
    }
    case kIfStatement: {
      _this->_internal_mutable_if_statement()->::vyper::IfStatement::MergeFrom(
          from._internal_if_statement());
      break;
    }
    case kFunctionCall: {
      _this->_internal_mutable_function_call()->::vyper::FunctionCall::MergeFrom(
          from._internal_function_call());
      break;
    }
    case kBuiltinCall: {
      _this->_internal_mutable_builtin_call()->::vyper::BuiltinCall::MergeFrom(
          from._internal_builtin_call());
      break;
    }
    case kDecl: {
      _this->_internal_mutable_decl()->::vyper::VarDecl::MergeFrom(
          from._internal_decl());
      break;
    }
    case kReturn: {
      _this->_internal_mutable_return_()->::vyper::ValOrOp::MergeFrom(
          from._internal_return_());
      break;
    }
    case STATEMENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statement::CopyFrom(const Statement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Statement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statement::IsInitialized() const {
  return true;
}

void Statement::InternalSwap(Statement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.statement_, other->_impl_.statement_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Statement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[0]);
}
// ===================================================================

class Uint256::_Internal {
 public:
};

Uint256::Uint256(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Uint256)
}
Uint256::Uint256(const Uint256& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.Uint256)
}

inline void Uint256::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.hb_) { ::uint64_t{0u} }

    , decltype(_impl_.lb_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Uint256::~Uint256() {
  // @@protoc_insertion_point(destructor:vyper.Uint256)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Uint256::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Uint256::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Uint256::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Uint256)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hb_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.lb_) -
      reinterpret_cast<char*>(&_impl_.hb_)) + sizeof(_impl_.lb_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Uint256::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 hb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.hb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 lb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.lb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Uint256::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Uint256)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 hb = 1;
  if (this->_internal_hb() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_hb(), target);
  }

  // uint64 lb = 2;
  if (this->_internal_lb() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_lb(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Uint256)
  return target;
}

::size_t Uint256::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Uint256)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 hb = 1;
  if (this->_internal_hb() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_hb());
  }

  // uint64 lb = 2;
  if (this->_internal_lb() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_lb());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Uint256::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Uint256::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Uint256::GetClassData() const { return &_class_data_; }


void Uint256::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Uint256*>(&to_msg);
  auto& from = static_cast<const Uint256&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Uint256)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hb() != 0) {
    _this->_internal_set_hb(from._internal_hb());
  }
  if (from._internal_lb() != 0) {
    _this->_internal_set_lb(from._internal_lb());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Uint256::CopyFrom(const Uint256& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Uint256)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Uint256::IsInitialized() const {
  return true;
}

void Uint256::InternalSwap(Uint256* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Uint256, _impl_.lb_)
      + sizeof(Uint256::_impl_.lb_)
      - PROTOBUF_FIELD_OFFSET(Uint256, _impl_.hb_)>(
          reinterpret_cast<char*>(&_impl_.hb_),
          reinterpret_cast<char*>(&other->_impl_.hb_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Uint256::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[1]);
}
// ===================================================================

class Value::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::Value, _impl_._oneof_case_);
  static const ::vyper::Uint256& num(const Value* msg);
};

const ::vyper::Uint256&
Value::_Internal::num(const Value* msg) {
  return *msg->_impl_.value_.num_;
}
void Value::set_allocated_num(::vyper::Uint256* num) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (num) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(num);
    if (message_arena != submessage_arena) {
      num = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num, submessage_arena);
    }
    set_has_num();
    _impl_.value_.num_ = num;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Value.num)
}
Value::Value(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Value)
}
Value::Value(const Value& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Value* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kStrLiteral: {
      _this->_internal_set_str_literal(from._internal_str_literal());
      break;
    }
    case kVarName: {
      _this->_internal_set_var_name(from._internal_var_name());
      break;
    }
    case kNum: {
      _this->_internal_mutable_num()->::vyper::Uint256::MergeFrom(
          from._internal_num());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.Value)
}

inline void Value::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_value();
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:vyper.Value)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Value::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void Value::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Value::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:vyper.Value)
  switch (value_case()) {
    case kStrLiteral: {
      _impl_.value_.str_literal_.Destroy();
      break;
    }
    case kVarName: {
      _impl_.value_.var_name_.Destroy();
      break;
    }
    case kNum: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.num_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void Value::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Value)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Value::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string str_literal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_str_literal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.Value.str_literal"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string var_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_var_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.Value.var_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Uint256 num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_num(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Value::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Value)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string str_literal = 1;
  if (value_case() == kStrLiteral) {
    const std::string& _s = this->_internal_str_literal();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.Value.str_literal");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string var_name = 2;
  if (value_case() == kVarName) {
    const std::string& _s = this->_internal_var_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.Value.var_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // .vyper.Uint256 num = 3;
  if (value_case() == kNum) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::num(this),
        _Internal::num(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Value)
  return target;
}

::size_t Value::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Value)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // string str_literal = 1;
    case kStrLiteral: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_str_literal());
      break;
    }
    // string var_name = 2;
    case kVarName: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_var_name());
      break;
    }
    // .vyper.Uint256 num = 3;
    case kNum: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.num_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Value::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Value::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Value::GetClassData() const { return &_class_data_; }


void Value::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Value*>(&to_msg);
  auto& from = static_cast<const Value&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Value)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kStrLiteral: {
      _this->_internal_set_str_literal(from._internal_str_literal());
      break;
    }
    case kVarName: {
      _this->_internal_set_var_name(from._internal_var_name());
      break;
    }
    case kNum: {
      _this->_internal_mutable_num()->::vyper::Uint256::MergeFrom(
          from._internal_num());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Value::CopyFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {
  return true;
}

void Value::InternalSwap(Value* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Value::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[2]);
}
// ===================================================================

class Operator::_Internal {
 public:
};

Operator::Operator(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:vyper.Operator)
}
Operator::Operator(const Operator& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Operator* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.Operator)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Operator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Operator::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Operator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[3]);
}
// ===================================================================

class Operation::_Internal {
 public:
  static const ::vyper::Value& val1(const Operation* msg);
  static const ::vyper::Value& val2(const Operation* msg);
  static const ::vyper::Operator& operator_(const Operation* msg);
};

const ::vyper::Value&
Operation::_Internal::val1(const Operation* msg) {
  return *msg->_impl_.val1_;
}
const ::vyper::Value&
Operation::_Internal::val2(const Operation* msg) {
  return *msg->_impl_.val2_;
}
const ::vyper::Operator&
Operation::_Internal::operator_(const Operation* msg) {
  return *msg->_impl_.operator__;
}
Operation::Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Operation)
}
Operation::Operation(const Operation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Operation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val1_){nullptr}
    , decltype(_impl_.val2_){nullptr}
    , decltype(_impl_.operator__){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_val1()) {
    _this->_impl_.val1_ = new ::vyper::Value(*from._impl_.val1_);
  }
  if (from._internal_has_val2()) {
    _this->_impl_.val2_ = new ::vyper::Value(*from._impl_.val2_);
  }
  if (from._internal_has_operator_()) {
    _this->_impl_.operator__ = new ::vyper::Operator(*from._impl_.operator__);
  }
  // @@protoc_insertion_point(copy_constructor:vyper.Operation)
}

inline void Operation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.val1_){nullptr}
    , decltype(_impl_.val2_){nullptr}
    , decltype(_impl_.operator__){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Operation::~Operation() {
  // @@protoc_insertion_point(destructor:vyper.Operation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Operation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.val1_;
  if (this != internal_default_instance()) delete _impl_.val2_;
  if (this != internal_default_instance()) delete _impl_.operator__;
}

void Operation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Operation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.val1_ != nullptr) {
    delete _impl_.val1_;
  }
  _impl_.val1_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.val2_ != nullptr) {
    delete _impl_.val2_;
  }
  _impl_.val2_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.operator__ != nullptr) {
    delete _impl_.operator__;
  }
  _impl_.operator__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Operation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.Value val1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_val1(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Value val2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val2(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Operator operator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_operator_(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Operation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Operation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.Value val1 = 1;
  if (this->_internal_has_val1()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::val1(this),
        _Internal::val1(this).GetCachedSize(), target, stream);
  }

  // .vyper.Value val2 = 2;
  if (this->_internal_has_val2()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::val2(this),
        _Internal::val2(this).GetCachedSize(), target, stream);
  }

  // .vyper.Operator operator = 3;
  if (this->_internal_has_operator_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::operator_(this),
        _Internal::operator_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Operation)
  return target;
}

::size_t Operation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Operation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vyper.Value val1 = 1;
  if (this->_internal_has_val1()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.val1_);
  }

  // .vyper.Value val2 = 2;
  if (this->_internal_has_val2()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.val2_);
  }

  // .vyper.Operator operator = 3;
  if (this->_internal_has_operator_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.operator__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Operation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Operation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Operation::GetClassData() const { return &_class_data_; }


void Operation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Operation*>(&to_msg);
  auto& from = static_cast<const Operation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Operation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_val1()) {
    _this->_internal_mutable_val1()->::vyper::Value::MergeFrom(
        from._internal_val1());
  }
  if (from._internal_has_val2()) {
    _this->_internal_mutable_val2()->::vyper::Value::MergeFrom(
        from._internal_val2());
  }
  if (from._internal_has_operator_()) {
    _this->_internal_mutable_operator_()->::vyper::Operator::MergeFrom(
        from._internal_operator_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Operation::CopyFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operation::IsInitialized() const {
  return true;
}

void Operation::InternalSwap(Operation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Operation, _impl_.operator__)
      + sizeof(Operation::_impl_.operator__)
      - PROTOBUF_FIELD_OFFSET(Operation, _impl_.val1_)>(
          reinterpret_cast<char*>(&_impl_.val1_),
          reinterpret_cast<char*>(&other->_impl_.val1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Operation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[4]);
}
// ===================================================================

class VarDecl::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::VarDecl, _impl_._oneof_case_);
  static const ::vyper::Type& type(const VarDecl* msg);
  static const ::vyper::SizedType& stype(const VarDecl* msg);
};

const ::vyper::Type&
VarDecl::_Internal::type(const VarDecl* msg) {
  return *msg->_impl_._type_.type_;
}
const ::vyper::SizedType&
VarDecl::_Internal::stype(const VarDecl* msg) {
  return *msg->_impl_._type_.stype_;
}
void VarDecl::set_allocated_type(::vyper::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear__type();
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
    _impl_._type_.type_ = type;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.VarDecl.type)
}
void VarDecl::set_allocated_stype(::vyper::SizedType* stype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear__type();
  if (stype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stype);
    if (message_arena != submessage_arena) {
      stype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stype, submessage_arena);
    }
    set_has_stype();
    _impl_._type_.stype_ = stype;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.VarDecl.stype)
}
VarDecl::VarDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.VarDecl)
}
VarDecl::VarDecl(const VarDecl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VarDecl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.var_name_) {}

    , decltype(_impl_._type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var_name().empty()) {
    _this->_impl_.var_name_.Set(from._internal_var_name(), _this->GetArenaForAllocation());
  }
  clear_has__type();
  switch (from._type_case()) {
    case kType: {
      _this->_internal_mutable_type()->::vyper::Type::MergeFrom(
          from._internal_type());
      break;
    }
    case kStype: {
      _this->_internal_mutable_stype()->::vyper::SizedType::MergeFrom(
          from._internal_stype());
      break;
    }
    case _TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.VarDecl)
}

inline void VarDecl::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.var_name_) {}

    , decltype(_impl_._type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has__type();
}

VarDecl::~VarDecl() {
  // @@protoc_insertion_point(destructor:vyper.VarDecl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VarDecl::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_name_.Destroy();
  if (has__type()) {
    clear__type();
  }
}

void VarDecl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VarDecl::clear__type() {
// @@protoc_insertion_point(one_of_clear_start:vyper.VarDecl)
  switch (_type_case()) {
    case kType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_._type_.type_;
      }
      break;
    }
    case kStype: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_._type_.stype_;
      }
      break;
    }
    case _TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = _TYPE_NOT_SET;
}


void VarDecl::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.VarDecl)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.var_name_.ClearToEmpty();
  clear__type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VarDecl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string var_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_var_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.VarDecl.var_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.SizedType stype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stype(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VarDecl::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.VarDecl)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string var_name = 1;
  if (!this->_internal_var_name().empty()) {
    const std::string& _s = this->_internal_var_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.VarDecl.var_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .vyper.Type type = 2;
  if (_type_case() == kType) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::type(this),
        _Internal::type(this).GetCachedSize(), target, stream);
  }

  // .vyper.SizedType stype = 3;
  if (_type_case() == kStype) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::stype(this),
        _Internal::stype(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.VarDecl)
  return target;
}

::size_t VarDecl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.VarDecl)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string var_name = 1;
  if (!this->_internal_var_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_var_name());
  }

  switch (_type_case()) {
    // .vyper.Type type = 2;
    case kType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_._type_.type_);
      break;
    }
    // .vyper.SizedType stype = 3;
    case kStype: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_._type_.stype_);
      break;
    }
    case _TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VarDecl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VarDecl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VarDecl::GetClassData() const { return &_class_data_; }


void VarDecl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VarDecl*>(&to_msg);
  auto& from = static_cast<const VarDecl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.VarDecl)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_var_name().empty()) {
    _this->_internal_set_var_name(from._internal_var_name());
  }
  switch (from._type_case()) {
    case kType: {
      _this->_internal_mutable_type()->::vyper::Type::MergeFrom(
          from._internal_type());
      break;
    }
    case kStype: {
      _this->_internal_mutable_stype()->::vyper::SizedType::MergeFrom(
          from._internal_stype());
      break;
    }
    case _TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VarDecl::CopyFrom(const VarDecl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.VarDecl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarDecl::IsInitialized() const {
  return true;
}

void VarDecl::InternalSwap(VarDecl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.var_name_, lhs_arena,
                                       &other->_impl_.var_name_, rhs_arena);
  swap(_impl_._type_, other->_impl_._type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VarDecl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[5]);
}
// ===================================================================

class ValOrOp::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::ValOrOp, _impl_._oneof_case_);
  static const ::vyper::Value& val(const ValOrOp* msg);
  static const ::vyper::Operation& op(const ValOrOp* msg);
  static const ::vyper::FunctionCall& func_call(const ValOrOp* msg);
  static const ::vyper::BuiltinCall& builtin_call(const ValOrOp* msg);
};

const ::vyper::Value&
ValOrOp::_Internal::val(const ValOrOp* msg) {
  return *msg->_impl_.value_or_op_.val_;
}
const ::vyper::Operation&
ValOrOp::_Internal::op(const ValOrOp* msg) {
  return *msg->_impl_.value_or_op_.op_;
}
const ::vyper::FunctionCall&
ValOrOp::_Internal::func_call(const ValOrOp* msg) {
  return *msg->_impl_.value_or_op_.func_call_;
}
const ::vyper::BuiltinCall&
ValOrOp::_Internal::builtin_call(const ValOrOp* msg) {
  return *msg->_impl_.value_or_op_.builtin_call_;
}
void ValOrOp::set_allocated_val(::vyper::Value* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value_or_op();
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(val);
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    set_has_val();
    _impl_.value_or_op_.val_ = val;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ValOrOp.val)
}
void ValOrOp::set_allocated_op(::vyper::Operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value_or_op();
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(op);
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    set_has_op();
    _impl_.value_or_op_.op_ = op;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ValOrOp.op)
}
void ValOrOp::set_allocated_func_call(::vyper::FunctionCall* func_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value_or_op();
  if (func_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(func_call);
    if (message_arena != submessage_arena) {
      func_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, func_call, submessage_arena);
    }
    set_has_func_call();
    _impl_.value_or_op_.func_call_ = func_call;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ValOrOp.func_call)
}
void ValOrOp::set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value_or_op();
  if (builtin_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(builtin_call);
    if (message_arena != submessage_arena) {
      builtin_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, builtin_call, submessage_arena);
    }
    set_has_builtin_call();
    _impl_.value_or_op_.builtin_call_ = builtin_call;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ValOrOp.builtin_call)
}
ValOrOp::ValOrOp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.ValOrOp)
}
ValOrOp::ValOrOp(const ValOrOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ValOrOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_or_op_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_value_or_op();
  switch (from.value_or_op_case()) {
    case kVal: {
      _this->_internal_mutable_val()->::vyper::Value::MergeFrom(
          from._internal_val());
      break;
    }
    case kOp: {
      _this->_internal_mutable_op()->::vyper::Operation::MergeFrom(
          from._internal_op());
      break;
    }
    case kFuncCall: {
      _this->_internal_mutable_func_call()->::vyper::FunctionCall::MergeFrom(
          from._internal_func_call());
      break;
    }
    case kBuiltinCall: {
      _this->_internal_mutable_builtin_call()->::vyper::BuiltinCall::MergeFrom(
          from._internal_builtin_call());
      break;
    }
    case VALUE_OR_OP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.ValOrOp)
}

inline void ValOrOp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_or_op_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_value_or_op();
}

ValOrOp::~ValOrOp() {
  // @@protoc_insertion_point(destructor:vyper.ValOrOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValOrOp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value_or_op()) {
    clear_value_or_op();
  }
}

void ValOrOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ValOrOp::clear_value_or_op() {
// @@protoc_insertion_point(one_of_clear_start:vyper.ValOrOp)
  switch (value_or_op_case()) {
    case kVal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_or_op_.val_;
      }
      break;
    }
    case kOp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_or_op_.op_;
      }
      break;
    }
    case kFuncCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_or_op_.func_call_;
      }
      break;
    }
    case kBuiltinCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_or_op_.builtin_call_;
      }
      break;
    }
    case VALUE_OR_OP_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_OR_OP_NOT_SET;
}


void ValOrOp::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.ValOrOp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value_or_op();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValOrOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.Value val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Operation op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.FunctionCall func_call = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_func_call(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.BuiltinCall builtin_call = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_builtin_call(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ValOrOp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.ValOrOp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.Value val = 1;
  if (value_or_op_case() == kVal) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::val(this),
        _Internal::val(this).GetCachedSize(), target, stream);
  }

  // .vyper.Operation op = 2;
  if (value_or_op_case() == kOp) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::op(this),
        _Internal::op(this).GetCachedSize(), target, stream);
  }

  // .vyper.FunctionCall func_call = 3;
  if (value_or_op_case() == kFuncCall) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::func_call(this),
        _Internal::func_call(this).GetCachedSize(), target, stream);
  }

  // .vyper.BuiltinCall builtin_call = 4;
  if (value_or_op_case() == kBuiltinCall) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::builtin_call(this),
        _Internal::builtin_call(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.ValOrOp)
  return target;
}

::size_t ValOrOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.ValOrOp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_or_op_case()) {
    // .vyper.Value val = 1;
    case kVal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_or_op_.val_);
      break;
    }
    // .vyper.Operation op = 2;
    case kOp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_or_op_.op_);
      break;
    }
    // .vyper.FunctionCall func_call = 3;
    case kFuncCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_or_op_.func_call_);
      break;
    }
    // .vyper.BuiltinCall builtin_call = 4;
    case kBuiltinCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_or_op_.builtin_call_);
      break;
    }
    case VALUE_OR_OP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ValOrOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ValOrOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ValOrOp::GetClassData() const { return &_class_data_; }


void ValOrOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ValOrOp*>(&to_msg);
  auto& from = static_cast<const ValOrOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.ValOrOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_or_op_case()) {
    case kVal: {
      _this->_internal_mutable_val()->::vyper::Value::MergeFrom(
          from._internal_val());
      break;
    }
    case kOp: {
      _this->_internal_mutable_op()->::vyper::Operation::MergeFrom(
          from._internal_op());
      break;
    }
    case kFuncCall: {
      _this->_internal_mutable_func_call()->::vyper::FunctionCall::MergeFrom(
          from._internal_func_call());
      break;
    }
    case kBuiltinCall: {
      _this->_internal_mutable_builtin_call()->::vyper::BuiltinCall::MergeFrom(
          from._internal_builtin_call());
      break;
    }
    case VALUE_OR_OP_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ValOrOp::CopyFrom(const ValOrOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.ValOrOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValOrOp::IsInitialized() const {
  return true;
}

void ValOrOp::InternalSwap(ValOrOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_or_op_, other->_impl_.value_or_op_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ValOrOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[6]);
}
// ===================================================================

class CodeBlock::_Internal {
 public:
};

CodeBlock::CodeBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.CodeBlock)
}
CodeBlock::CodeBlock(const CodeBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CodeBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){from._impl_.statements_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.CodeBlock)
}

inline void CodeBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CodeBlock::~CodeBlock() {
  // @@protoc_insertion_point(destructor:vyper.CodeBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CodeBlock::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.statements_.~RepeatedPtrField();
}

void CodeBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CodeBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.CodeBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.statements_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CodeBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vyper.Statement statements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_statements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CodeBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.CodeBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vyper.Statement statements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_statements_size()); i < n; i++) {
    const auto& repfield = this->_internal_statements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.CodeBlock)
  return target;
}

::size_t CodeBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.CodeBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vyper.Statement statements = 1;
  total_size += 1UL * this->_internal_statements_size();
  for (const auto& msg : this->_impl_.statements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CodeBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CodeBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CodeBlock::GetClassData() const { return &_class_data_; }


void CodeBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CodeBlock*>(&to_msg);
  auto& from = static_cast<const CodeBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.CodeBlock)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.statements_.MergeFrom(from._impl_.statements_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CodeBlock::CopyFrom(const CodeBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.CodeBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodeBlock::IsInitialized() const {
  return true;
}

void CodeBlock::InternalSwap(CodeBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.statements_.InternalSwap(&other->_impl_.statements_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CodeBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[7]);
}
// ===================================================================

class ArgDef::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::ArgDef, _impl_._oneof_case_);
  static const ::vyper::SizedType& stype(const ArgDef* msg);
  static const ::vyper::Type& type(const ArgDef* msg);
};

const ::vyper::SizedType&
ArgDef::_Internal::stype(const ArgDef* msg) {
  return *msg->_impl_.arg_.stype_;
}
const ::vyper::Type&
ArgDef::_Internal::type(const ArgDef* msg) {
  return *msg->_impl_.arg_.type_;
}
void ArgDef::set_allocated_stype(::vyper::SizedType* stype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_arg();
  if (stype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stype);
    if (message_arena != submessage_arena) {
      stype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stype, submessage_arena);
    }
    set_has_stype();
    _impl_.arg_.stype_ = stype;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ArgDef.stype)
}
void ArgDef::set_allocated_type(::vyper::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_arg();
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
    _impl_.arg_.type_ = type;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.ArgDef.type)
}
ArgDef::ArgDef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.ArgDef)
}
ArgDef::ArgDef(const ArgDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArgDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.arg_name_) {}

    , decltype(_impl_.arg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.arg_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.arg_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_arg_name().empty()) {
    _this->_impl_.arg_name_.Set(from._internal_arg_name(), _this->GetArenaForAllocation());
  }
  clear_has_arg();
  switch (from.arg_case()) {
    case kStype: {
      _this->_internal_mutable_stype()->::vyper::SizedType::MergeFrom(
          from._internal_stype());
      break;
    }
    case kType: {
      _this->_internal_mutable_type()->::vyper::Type::MergeFrom(
          from._internal_type());
      break;
    }
    case ARG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.ArgDef)
}

inline void ArgDef::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.arg_name_) {}

    , decltype(_impl_.arg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.arg_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.arg_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_arg();
}

ArgDef::~ArgDef() {
  // @@protoc_insertion_point(destructor:vyper.ArgDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArgDef::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.arg_name_.Destroy();
  if (has_arg()) {
    clear_arg();
  }
}

void ArgDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArgDef::clear_arg() {
// @@protoc_insertion_point(one_of_clear_start:vyper.ArgDef)
  switch (arg_case()) {
    case kStype: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.arg_.stype_;
      }
      break;
    }
    case kType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.arg_.type_;
      }
      break;
    }
    case ARG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ARG_NOT_SET;
}


void ArgDef::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.ArgDef)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.arg_name_.ClearToEmpty();
  clear_arg();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArgDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.SizedType stype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stype(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string arg_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_arg_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.ArgDef.arg_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ArgDef::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.ArgDef)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.SizedType stype = 1;
  if (arg_case() == kStype) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stype(this),
        _Internal::stype(this).GetCachedSize(), target, stream);
  }

  // .vyper.Type type = 2;
  if (arg_case() == kType) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::type(this),
        _Internal::type(this).GetCachedSize(), target, stream);
  }

  // string arg_name = 3;
  if (!this->_internal_arg_name().empty()) {
    const std::string& _s = this->_internal_arg_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.ArgDef.arg_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.ArgDef)
  return target;
}

::size_t ArgDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.ArgDef)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string arg_name = 3;
  if (!this->_internal_arg_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_arg_name());
  }

  switch (arg_case()) {
    // .vyper.SizedType stype = 1;
    case kStype: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.arg_.stype_);
      break;
    }
    // .vyper.Type type = 2;
    case kType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.arg_.type_);
      break;
    }
    case ARG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArgDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArgDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArgDef::GetClassData() const { return &_class_data_; }


void ArgDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArgDef*>(&to_msg);
  auto& from = static_cast<const ArgDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.ArgDef)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_arg_name().empty()) {
    _this->_internal_set_arg_name(from._internal_arg_name());
  }
  switch (from.arg_case()) {
    case kStype: {
      _this->_internal_mutable_stype()->::vyper::SizedType::MergeFrom(
          from._internal_stype());
      break;
    }
    case kType: {
      _this->_internal_mutable_type()->::vyper::Type::MergeFrom(
          from._internal_type());
      break;
    }
    case ARG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArgDef::CopyFrom(const ArgDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.ArgDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArgDef::IsInitialized() const {
  return true;
}

void ArgDef::InternalSwap(ArgDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.arg_name_, lhs_arena,
                                       &other->_impl_.arg_name_, rhs_arena);
  swap(_impl_.arg_, other->_impl_.arg_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArgDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[8]);
}
// ===================================================================

class FunctionDef::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::FunctionDef, _impl_._oneof_case_);
  static const ::vyper::CodeBlock& block(const FunctionDef* msg);
  static const ::vyper::Type& return_type(const FunctionDef* msg);
  static const ::vyper::SizedType& return_stype(const FunctionDef* msg);
};

const ::vyper::CodeBlock&
FunctionDef::_Internal::block(const FunctionDef* msg) {
  return *msg->_impl_.block_;
}
const ::vyper::Type&
FunctionDef::_Internal::return_type(const FunctionDef* msg) {
  return *msg->_impl_.ret_type_.return_type_;
}
const ::vyper::SizedType&
FunctionDef::_Internal::return_stype(const FunctionDef* msg) {
  return *msg->_impl_.ret_type_.return_stype_;
}
void FunctionDef::set_allocated_return_type(::vyper::Type* return_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ret_type();
  if (return_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(return_type);
    if (message_arena != submessage_arena) {
      return_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, return_type, submessage_arena);
    }
    set_has_return_type();
    _impl_.ret_type_.return_type_ = return_type;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.return_type)
}
void FunctionDef::set_allocated_return_stype(::vyper::SizedType* return_stype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ret_type();
  if (return_stype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(return_stype);
    if (message_arena != submessage_arena) {
      return_stype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, return_stype, submessage_arena);
    }
    set_has_return_stype();
    _impl_.ret_type_.return_stype_ = return_stype;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.return_stype)
}
FunctionDef::FunctionDef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.FunctionDef)
}
FunctionDef::FunctionDef(const FunctionDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FunctionDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.function_name_) {}

    , decltype(_impl_.block_){nullptr}
    , decltype(_impl_.external_) {}

    , decltype(_impl_.ret_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_function_name().empty()) {
    _this->_impl_.function_name_.Set(from._internal_function_name(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::vyper::CodeBlock(*from._impl_.block_);
  }
  _this->_impl_.external_ = from._impl_.external_;
  clear_has_ret_type();
  switch (from.ret_type_case()) {
    case kReturnType: {
      _this->_internal_mutable_return_type()->::vyper::Type::MergeFrom(
          from._internal_return_type());
      break;
    }
    case kReturnStype: {
      _this->_internal_mutable_return_stype()->::vyper::SizedType::MergeFrom(
          from._internal_return_stype());
      break;
    }
    case RET_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.FunctionDef)
}

inline void FunctionDef::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.function_name_) {}

    , decltype(_impl_.block_){nullptr}
    , decltype(_impl_.external_) { false }

    , decltype(_impl_.ret_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_ret_type();
}

FunctionDef::~FunctionDef() {
  // @@protoc_insertion_point(destructor:vyper.FunctionDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FunctionDef::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.function_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.block_;
  if (has_ret_type()) {
    clear_ret_type();
  }
}

void FunctionDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FunctionDef::clear_ret_type() {
// @@protoc_insertion_point(one_of_clear_start:vyper.FunctionDef)
  switch (ret_type_case()) {
    case kReturnType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ret_type_.return_type_;
      }
      break;
    }
    case kReturnStype: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ret_type_.return_stype_;
      }
      break;
    }
    case RET_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RET_TYPE_NOT_SET;
}


void FunctionDef::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.FunctionDef)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.function_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _impl_.external_ = false;
  clear_ret_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string function_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.FunctionDef.function_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .vyper.ArgDef args = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.CodeBlock block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool external = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.external_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Type return_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_return_type(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.SizedType return_stype = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_return_stype(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FunctionDef::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.FunctionDef)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string function_name = 1;
  if (!this->_internal_function_name().empty()) {
    const std::string& _s = this->_internal_function_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.FunctionDef.function_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .vyper.ArgDef args = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .vyper.CodeBlock block = 3;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  // bool external = 4;
  if (this->_internal_external() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_external(), target);
  }

  // .vyper.Type return_type = 5;
  if (ret_type_case() == kReturnType) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::return_type(this),
        _Internal::return_type(this).GetCachedSize(), target, stream);
  }

  // .vyper.SizedType return_stype = 6;
  if (ret_type_case() == kReturnStype) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::return_stype(this),
        _Internal::return_stype(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.FunctionDef)
  return target;
}

::size_t FunctionDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.FunctionDef)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vyper.ArgDef args = 2;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string function_name = 1;
  if (!this->_internal_function_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_function_name());
  }

  // .vyper.CodeBlock block = 3;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  // bool external = 4;
  if (this->_internal_external() != 0) {
    total_size += 2;
  }

  switch (ret_type_case()) {
    // .vyper.Type return_type = 5;
    case kReturnType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ret_type_.return_type_);
      break;
    }
    // .vyper.SizedType return_stype = 6;
    case kReturnStype: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ret_type_.return_stype_);
      break;
    }
    case RET_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FunctionDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FunctionDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FunctionDef::GetClassData() const { return &_class_data_; }


void FunctionDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FunctionDef*>(&to_msg);
  auto& from = static_cast<const FunctionDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.FunctionDef)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_function_name().empty()) {
    _this->_internal_set_function_name(from._internal_function_name());
  }
  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::vyper::CodeBlock::MergeFrom(
        from._internal_block());
  }
  if (from._internal_external() != 0) {
    _this->_internal_set_external(from._internal_external());
  }
  switch (from.ret_type_case()) {
    case kReturnType: {
      _this->_internal_mutable_return_type()->::vyper::Type::MergeFrom(
          from._internal_return_type());
      break;
    }
    case kReturnStype: {
      _this->_internal_mutable_return_stype()->::vyper::SizedType::MergeFrom(
          from._internal_return_stype());
      break;
    }
    case RET_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FunctionDef::CopyFrom(const FunctionDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.FunctionDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionDef::IsInitialized() const {
  return true;
}

void FunctionDef::InternalSwap(FunctionDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.function_name_, lhs_arena,
                                       &other->_impl_.function_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FunctionDef, _impl_.external_)
      + sizeof(FunctionDef::_impl_.external_)
      - PROTOBUF_FIELD_OFFSET(FunctionDef, _impl_.block_)>(
          reinterpret_cast<char*>(&_impl_.block_),
          reinterpret_cast<char*>(&other->_impl_.block_));
  swap(_impl_.ret_type_, other->_impl_.ret_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[9]);
}
// ===================================================================

class Type::_Internal {
 public:
};

Type::Type(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Type)
}
Type::Type(const Type& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.Type)
}

inline void Type::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.typeval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Type::~Type() {
  // @@protoc_insertion_point(destructor:vyper.Type)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Type::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Type::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Type::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Type)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.typeval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Type::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.TYPE_ENUM typeVal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_typeval(static_cast<::vyper::TYPE_ENUM>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Type::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Type)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.TYPE_ENUM typeVal = 1;
  if (this->_internal_typeval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_typeval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Type)
  return target;
}

::size_t Type::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Type)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vyper.TYPE_ENUM typeVal = 1;
  if (this->_internal_typeval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_typeval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Type::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Type::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Type::GetClassData() const { return &_class_data_; }


void Type::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Type*>(&to_msg);
  auto& from = static_cast<const Type&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Type)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_typeval() != 0) {
    _this->_internal_set_typeval(from._internal_typeval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Type::CopyFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Type)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Type::IsInitialized() const {
  return true;
}

void Type::InternalSwap(Type* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.typeval_, other->_impl_.typeval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Type::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[10]);
}
// ===================================================================

class SizedType::_Internal {
 public:
};

SizedType::SizedType(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.SizedType)
}
SizedType::SizedType(const SizedType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.SizedType)
}

inline void SizedType::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.typeval_) { 0 }

    , decltype(_impl_.size_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SizedType::~SizedType() {
  // @@protoc_insertion_point(destructor:vyper.SizedType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SizedType::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SizedType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SizedType::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.SizedType)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.typeval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.size_) -
      reinterpret_cast<char*>(&_impl_.typeval_)) + sizeof(_impl_.size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SizedType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.SIZED_TYPE_ENUM typeVal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_typeval(static_cast<::vyper::SIZED_TYPE_ENUM>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SizedType::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.SizedType)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.SIZED_TYPE_ENUM typeVal = 1;
  if (this->_internal_typeval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_typeval(), target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.SizedType)
  return target;
}

::size_t SizedType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.SizedType)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vyper.SIZED_TYPE_ENUM typeVal = 1;
  if (this->_internal_typeval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_typeval());
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SizedType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SizedType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SizedType::GetClassData() const { return &_class_data_; }


void SizedType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SizedType*>(&to_msg);
  auto& from = static_cast<const SizedType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.SizedType)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_typeval() != 0) {
    _this->_internal_set_typeval(from._internal_typeval());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SizedType::CopyFrom(const SizedType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.SizedType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SizedType::IsInitialized() const {
  return true;
}

void SizedType::InternalSwap(SizedType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SizedType, _impl_.size_)
      + sizeof(SizedType::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(SizedType, _impl_.typeval_)>(
          reinterpret_cast<char*>(&_impl_.typeval_),
          reinterpret_cast<char*>(&other->_impl_.typeval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SizedType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[11]);
}
// ===================================================================

class Assignment::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::Assignment, _impl_._oneof_case_);
  static const ::vyper::VarDecl& decl(const Assignment* msg);
  static const ::vyper::ValOrOp& value(const Assignment* msg);
};

const ::vyper::VarDecl&
Assignment::_Internal::decl(const Assignment* msg) {
  return *msg->_impl_.var_.decl_;
}
const ::vyper::ValOrOp&
Assignment::_Internal::value(const Assignment* msg) {
  return *msg->_impl_.value_;
}
void Assignment::set_allocated_decl(::vyper::VarDecl* decl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_var();
  if (decl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decl);
    if (message_arena != submessage_arena) {
      decl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decl, submessage_arena);
    }
    set_has_decl();
    _impl_.var_.decl_ = decl;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Assignment.decl)
}
Assignment::Assignment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.Assignment)
}
Assignment::Assignment(const Assignment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Assignment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::vyper::ValOrOp(*from._impl_.value_);
  }
  clear_has_var();
  switch (from.var_case()) {
    case kVariableName: {
      _this->_internal_set_variable_name(from._internal_variable_name());
      break;
    }
    case kDecl: {
      _this->_internal_mutable_decl()->::vyper::VarDecl::MergeFrom(
          from._internal_decl());
      break;
    }
    case VAR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.Assignment)
}

inline void Assignment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_var();
}

Assignment::~Assignment() {
  // @@protoc_insertion_point(destructor:vyper.Assignment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Assignment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.value_;
  if (has_var()) {
    clear_var();
  }
}

void Assignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Assignment::clear_var() {
// @@protoc_insertion_point(one_of_clear_start:vyper.Assignment)
  switch (var_case()) {
    case kVariableName: {
      _impl_.var_.variable_name_.Destroy();
      break;
    }
    case kDecl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.var_.decl_;
      }
      break;
    }
    case VAR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VAR_NOT_SET;
}


void Assignment::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.Assignment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  clear_var();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assignment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string variable_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_variable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.Assignment.variable_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.VarDecl decl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_decl(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.ValOrOp value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Assignment::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.Assignment)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string variable_name = 1;
  if (var_case() == kVariableName) {
    const std::string& _s = this->_internal_variable_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.Assignment.variable_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .vyper.VarDecl decl = 2;
  if (var_case() == kDecl) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::decl(this),
        _Internal::decl(this).GetCachedSize(), target, stream);
  }

  // .vyper.ValOrOp value = 3;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.Assignment)
  return target;
}

::size_t Assignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.Assignment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vyper.ValOrOp value = 3;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  switch (var_case()) {
    // string variable_name = 1;
    case kVariableName: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_variable_name());
      break;
    }
    // .vyper.VarDecl decl = 2;
    case kDecl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.var_.decl_);
      break;
    }
    case VAR_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Assignment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Assignment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Assignment::GetClassData() const { return &_class_data_; }


void Assignment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Assignment*>(&to_msg);
  auto& from = static_cast<const Assignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.Assignment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::vyper::ValOrOp::MergeFrom(
        from._internal_value());
  }
  switch (from.var_case()) {
    case kVariableName: {
      _this->_internal_set_variable_name(from._internal_variable_name());
      break;
    }
    case kDecl: {
      _this->_internal_mutable_decl()->::vyper::VarDecl::MergeFrom(
          from._internal_decl());
      break;
    }
    case VAR_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Assignment::CopyFrom(const Assignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.Assignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assignment::IsInitialized() const {
  return true;
}

void Assignment::InternalSwap(Assignment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_.var_, other->_impl_.var_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Assignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[12]);
}
// ===================================================================

class IfStatement::_Internal {
 public:
  static const ::vyper::CodeBlock& block(const IfStatement* msg);
};

const ::vyper::CodeBlock&
IfStatement::_Internal::block(const IfStatement* msg) {
  return *msg->_impl_.block_;
}
IfStatement::IfStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.IfStatement)
}
IfStatement::IfStatement(const IfStatement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IfStatement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.condition_) {}

    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.condition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.condition_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_condition().empty()) {
    _this->_impl_.condition_.Set(from._internal_condition(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::vyper::CodeBlock(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:vyper.IfStatement)
}

inline void IfStatement::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.condition_) {}

    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.condition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.condition_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IfStatement::~IfStatement() {
  // @@protoc_insertion_point(destructor:vyper.IfStatement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IfStatement::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.condition_.Destroy();
  if (this != internal_default_instance()) delete _impl_.block_;
}

void IfStatement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IfStatement::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.IfStatement)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.condition_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IfStatement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string condition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_condition();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.IfStatement.condition"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.CodeBlock block = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IfStatement::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.IfStatement)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string condition = 1;
  if (!this->_internal_condition().empty()) {
    const std::string& _s = this->_internal_condition();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.IfStatement.condition");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .vyper.CodeBlock block = 2;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.IfStatement)
  return target;
}

::size_t IfStatement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.IfStatement)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string condition = 1;
  if (!this->_internal_condition().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_condition());
  }

  // .vyper.CodeBlock block = 2;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IfStatement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IfStatement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IfStatement::GetClassData() const { return &_class_data_; }


void IfStatement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IfStatement*>(&to_msg);
  auto& from = static_cast<const IfStatement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.IfStatement)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_condition().empty()) {
    _this->_internal_set_condition(from._internal_condition());
  }
  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::vyper::CodeBlock::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IfStatement::CopyFrom(const IfStatement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.IfStatement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IfStatement::IsInitialized() const {
  return true;
}

void IfStatement::InternalSwap(IfStatement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.condition_, lhs_arena,
                                       &other->_impl_.condition_, rhs_arena);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IfStatement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[13]);
}
// ===================================================================

class FunctionCall::_Internal {
 public:
};

FunctionCall::FunctionCall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.FunctionCall)
}
FunctionCall::FunctionCall(const FunctionCall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FunctionCall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.function_name_) {}

    , decltype(_impl_.self_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_function_name().empty()) {
    _this->_impl_.function_name_.Set(from._internal_function_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.self_ = from._impl_.self_;
  // @@protoc_insertion_point(copy_constructor:vyper.FunctionCall)
}

inline void FunctionCall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.function_name_) {}

    , decltype(_impl_.self_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FunctionCall::~FunctionCall() {
  // @@protoc_insertion_point(destructor:vyper.FunctionCall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FunctionCall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.function_name_.Destroy();
}

void FunctionCall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FunctionCall::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.FunctionCall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.function_name_.ClearToEmpty();
  _impl_.self_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionCall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string function_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vyper.FunctionCall.function_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .vyper.ValOrOp args = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool self = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.self_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FunctionCall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.FunctionCall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string function_name = 1;
  if (!this->_internal_function_name().empty()) {
    const std::string& _s = this->_internal_function_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.FunctionCall.function_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .vyper.ValOrOp args = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool self = 3;
  if (this->_internal_self() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_self(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.FunctionCall)
  return target;
}

::size_t FunctionCall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.FunctionCall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vyper.ValOrOp args = 2;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string function_name = 1;
  if (!this->_internal_function_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_function_name());
  }

  // bool self = 3;
  if (this->_internal_self() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FunctionCall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FunctionCall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FunctionCall::GetClassData() const { return &_class_data_; }


void FunctionCall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FunctionCall*>(&to_msg);
  auto& from = static_cast<const FunctionCall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.FunctionCall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_function_name().empty()) {
    _this->_internal_set_function_name(from._internal_function_name());
  }
  if (from._internal_self() != 0) {
    _this->_internal_set_self(from._internal_self());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FunctionCall::CopyFrom(const FunctionCall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.FunctionCall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionCall::IsInitialized() const {
  return true;
}

void FunctionCall::InternalSwap(FunctionCall* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.function_name_, lhs_arena,
                                       &other->_impl_.function_name_, rhs_arena);

  swap(_impl_.self_, other->_impl_.self_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionCall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[14]);
}
// ===================================================================

class ConcatCall::_Internal {
 public:
};

ConcatCall::ConcatCall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.ConcatCall)
}
ConcatCall::ConcatCall(const ConcatCall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConcatCall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.ConcatCall)
}

inline void ConcatCall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConcatCall::~ConcatCall() {
  // @@protoc_insertion_point(destructor:vyper.ConcatCall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConcatCall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
}

void ConcatCall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConcatCall::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.ConcatCall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConcatCall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "vyper.ConcatCall.args"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConcatCall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.ConcatCall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string args = 1;
  for (int i = 0, n = this->_internal_args_size(); i < n; ++i) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "vyper.ConcatCall.args");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.ConcatCall)
  return target;
}

::size_t ConcatCall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.ConcatCall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string args = 1;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.args_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConcatCall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConcatCall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConcatCall::GetClassData() const { return &_class_data_; }


void ConcatCall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConcatCall*>(&to_msg);
  auto& from = static_cast<const ConcatCall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.ConcatCall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConcatCall::CopyFrom(const ConcatCall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.ConcatCall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConcatCall::IsInitialized() const {
  return true;
}

void ConcatCall::InternalSwap(ConcatCall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConcatCall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[15]);
}
// ===================================================================

class ConvertCall::_Internal {
 public:
  static const ::vyper::ValOrOp& value(const ConvertCall* msg);
  static const ::vyper::Type& type(const ConvertCall* msg);
};

const ::vyper::ValOrOp&
ConvertCall::_Internal::value(const ConvertCall* msg) {
  return *msg->_impl_.value_;
}
const ::vyper::Type&
ConvertCall::_Internal::type(const ConvertCall* msg) {
  return *msg->_impl_.type_;
}
ConvertCall::ConvertCall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.ConvertCall)
}
ConvertCall::ConvertCall(const ConvertCall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConvertCall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.type_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::vyper::ValOrOp(*from._impl_.value_);
  }
  if (from._internal_has_type()) {
    _this->_impl_.type_ = new ::vyper::Type(*from._impl_.type_);
  }
  // @@protoc_insertion_point(copy_constructor:vyper.ConvertCall)
}

inline void ConvertCall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.type_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConvertCall::~ConvertCall() {
  // @@protoc_insertion_point(destructor:vyper.ConvertCall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConvertCall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.value_;
  if (this != internal_default_instance()) delete _impl_.type_;
}

void ConvertCall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConvertCall::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.ConvertCall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.type_ != nullptr) {
    delete _impl_.type_;
  }
  _impl_.type_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConvertCall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.ValOrOp value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConvertCall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.ConvertCall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.ValOrOp value = 1;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // .vyper.Type type = 2;
  if (this->_internal_has_type()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::type(this),
        _Internal::type(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.ConvertCall)
  return target;
}

::size_t ConvertCall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.ConvertCall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vyper.ValOrOp value = 1;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  // .vyper.Type type = 2;
  if (this->_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.type_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConvertCall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConvertCall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConvertCall::GetClassData() const { return &_class_data_; }


void ConvertCall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConvertCall*>(&to_msg);
  auto& from = static_cast<const ConvertCall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.ConvertCall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::vyper::ValOrOp::MergeFrom(
        from._internal_value());
  }
  if (from._internal_has_type()) {
    _this->_internal_mutable_type()->::vyper::Type::MergeFrom(
        from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConvertCall::CopyFrom(const ConvertCall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.ConvertCall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvertCall::IsInitialized() const {
  return true;
}

void ConvertCall::InternalSwap(ConvertCall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConvertCall, _impl_.type_)
      + sizeof(ConvertCall::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ConvertCall, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConvertCall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[16]);
}
// ===================================================================

class BuiltinCall::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::vyper::BuiltinCall, _impl_._oneof_case_);
  static const ::vyper::ConcatCall& concat(const BuiltinCall* msg);
  static const ::vyper::ConvertCall& convert(const BuiltinCall* msg);
};

const ::vyper::ConcatCall&
BuiltinCall::_Internal::concat(const BuiltinCall* msg) {
  return *msg->_impl_.call_.concat_;
}
const ::vyper::ConvertCall&
BuiltinCall::_Internal::convert(const BuiltinCall* msg) {
  return *msg->_impl_.call_.convert_;
}
void BuiltinCall::set_allocated_concat(::vyper::ConcatCall* concat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_call();
  if (concat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(concat);
    if (message_arena != submessage_arena) {
      concat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concat, submessage_arena);
    }
    set_has_concat();
    _impl_.call_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.BuiltinCall.concat)
}
void BuiltinCall::set_allocated_convert(::vyper::ConvertCall* convert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_call();
  if (convert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(convert);
    if (message_arena != submessage_arena) {
      convert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, convert, submessage_arena);
    }
    set_has_convert();
    _impl_.call_.convert_ = convert;
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.BuiltinCall.convert)
}
BuiltinCall::BuiltinCall(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.BuiltinCall)
}
BuiltinCall::BuiltinCall(const BuiltinCall& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BuiltinCall* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.call_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_call();
  switch (from.call_case()) {
    case kConcat: {
      _this->_internal_mutable_concat()->::vyper::ConcatCall::MergeFrom(
          from._internal_concat());
      break;
    }
    case kConvert: {
      _this->_internal_mutable_convert()->::vyper::ConvertCall::MergeFrom(
          from._internal_convert());
      break;
    }
    case CALL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vyper.BuiltinCall)
}

inline void BuiltinCall::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.call_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_call();
}

BuiltinCall::~BuiltinCall() {
  // @@protoc_insertion_point(destructor:vyper.BuiltinCall)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BuiltinCall::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_call()) {
    clear_call();
  }
}

void BuiltinCall::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BuiltinCall::clear_call() {
// @@protoc_insertion_point(one_of_clear_start:vyper.BuiltinCall)
  switch (call_case()) {
    case kConcat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.call_.concat_;
      }
      break;
    }
    case kConvert: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.call_.convert_;
      }
      break;
    }
    case CALL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CALL_NOT_SET;
}


void BuiltinCall::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.BuiltinCall)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_call();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BuiltinCall::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vyper.ConcatCall concat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_concat(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .vyper.ConvertCall convert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_convert(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BuiltinCall::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.BuiltinCall)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vyper.ConcatCall concat = 1;
  if (call_case() == kConcat) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::concat(this),
        _Internal::concat(this).GetCachedSize(), target, stream);
  }

  // .vyper.ConvertCall convert = 2;
  if (call_case() == kConvert) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::convert(this),
        _Internal::convert(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.BuiltinCall)
  return target;
}

::size_t BuiltinCall::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.BuiltinCall)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (call_case()) {
    // .vyper.ConcatCall concat = 1;
    case kConcat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.call_.concat_);
      break;
    }
    // .vyper.ConvertCall convert = 2;
    case kConvert: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.call_.convert_);
      break;
    }
    case CALL_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BuiltinCall::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BuiltinCall::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BuiltinCall::GetClassData() const { return &_class_data_; }


void BuiltinCall::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BuiltinCall*>(&to_msg);
  auto& from = static_cast<const BuiltinCall&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.BuiltinCall)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.call_case()) {
    case kConcat: {
      _this->_internal_mutable_concat()->::vyper::ConcatCall::MergeFrom(
          from._internal_concat());
      break;
    }
    case kConvert: {
      _this->_internal_mutable_convert()->::vyper::ConvertCall::MergeFrom(
          from._internal_convert());
      break;
    }
    case CALL_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BuiltinCall::CopyFrom(const BuiltinCall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.BuiltinCall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuiltinCall::IsInitialized() const {
  return true;
}

void BuiltinCall::InternalSwap(BuiltinCall* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.call_, other->_impl_.call_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BuiltinCall::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[17]);
}
// ===================================================================

class VyperContract::_Internal {
 public:
};

VyperContract::VyperContract(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:vyper.VyperContract)
}
VyperContract::VyperContract(const VyperContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VyperContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.functions_){from._impl_.functions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vyper.VyperContract)
}

inline void VyperContract::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.functions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VyperContract::~VyperContract() {
  // @@protoc_insertion_point(destructor:vyper.VyperContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VyperContract::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.functions_.~RepeatedPtrField();
}

void VyperContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VyperContract::Clear() {
// @@protoc_insertion_point(message_clear_start:vyper.VyperContract)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.functions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VyperContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vyper.FunctionDef functions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_functions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VyperContract::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vyper.VyperContract)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vyper.FunctionDef functions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_functions_size()); i < n; i++) {
    const auto& repfield = this->_internal_functions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vyper.VyperContract)
  return target;
}

::size_t VyperContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vyper.VyperContract)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vyper.FunctionDef functions = 1;
  total_size += 1UL * this->_internal_functions_size();
  for (const auto& msg : this->_impl_.functions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VyperContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VyperContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VyperContract::GetClassData() const { return &_class_data_; }


void VyperContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VyperContract*>(&to_msg);
  auto& from = static_cast<const VyperContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vyper.VyperContract)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.functions_.MergeFrom(from._impl_.functions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VyperContract::CopyFrom(const VyperContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vyper.VyperContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VyperContract::IsInitialized() const {
  return true;
}

void VyperContract::InternalSwap(VyperContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.functions_.InternalSwap(&other->_impl_.functions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VyperContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vyper_2eproto_getter, &descriptor_table_vyper_2eproto_once,
      file_level_metadata_vyper_2eproto[18]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace vyper
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vyper::Statement*
Arena::CreateMaybeMessage< ::vyper::Statement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Statement >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Uint256*
Arena::CreateMaybeMessage< ::vyper::Uint256 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Uint256 >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Value*
Arena::CreateMaybeMessage< ::vyper::Value >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Value >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Operator*
Arena::CreateMaybeMessage< ::vyper::Operator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Operator >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Operation*
Arena::CreateMaybeMessage< ::vyper::Operation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Operation >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::VarDecl*
Arena::CreateMaybeMessage< ::vyper::VarDecl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::VarDecl >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::ValOrOp*
Arena::CreateMaybeMessage< ::vyper::ValOrOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::ValOrOp >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::CodeBlock*
Arena::CreateMaybeMessage< ::vyper::CodeBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::CodeBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::ArgDef*
Arena::CreateMaybeMessage< ::vyper::ArgDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::ArgDef >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::FunctionDef*
Arena::CreateMaybeMessage< ::vyper::FunctionDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::FunctionDef >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Type*
Arena::CreateMaybeMessage< ::vyper::Type >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Type >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::SizedType*
Arena::CreateMaybeMessage< ::vyper::SizedType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::SizedType >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::Assignment*
Arena::CreateMaybeMessage< ::vyper::Assignment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::Assignment >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::IfStatement*
Arena::CreateMaybeMessage< ::vyper::IfStatement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::IfStatement >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::FunctionCall*
Arena::CreateMaybeMessage< ::vyper::FunctionCall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::FunctionCall >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::ConcatCall*
Arena::CreateMaybeMessage< ::vyper::ConcatCall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::ConcatCall >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::ConvertCall*
Arena::CreateMaybeMessage< ::vyper::ConvertCall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::ConvertCall >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::BuiltinCall*
Arena::CreateMaybeMessage< ::vyper::BuiltinCall >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::BuiltinCall >(arena);
}
template<> PROTOBUF_NOINLINE ::vyper::VyperContract*
Arena::CreateMaybeMessage< ::vyper::VyperContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vyper::VyperContract >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
