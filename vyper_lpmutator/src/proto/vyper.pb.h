// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vyper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_vyper_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vyper_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_vyper_2eproto;
namespace vyper {
class ArgDef;
struct ArgDefDefaultTypeInternal;
extern ArgDefDefaultTypeInternal _ArgDef_default_instance_;
class Assignment;
struct AssignmentDefaultTypeInternal;
extern AssignmentDefaultTypeInternal _Assignment_default_instance_;
class BuiltinCall;
struct BuiltinCallDefaultTypeInternal;
extern BuiltinCallDefaultTypeInternal _BuiltinCall_default_instance_;
class CodeBlock;
struct CodeBlockDefaultTypeInternal;
extern CodeBlockDefaultTypeInternal _CodeBlock_default_instance_;
class ConcatCall;
struct ConcatCallDefaultTypeInternal;
extern ConcatCallDefaultTypeInternal _ConcatCall_default_instance_;
class ConvertCall;
struct ConvertCallDefaultTypeInternal;
extern ConvertCallDefaultTypeInternal _ConvertCall_default_instance_;
class FunctionCall;
struct FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class FunctionDef;
struct FunctionDefDefaultTypeInternal;
extern FunctionDefDefaultTypeInternal _FunctionDef_default_instance_;
class IfStatement;
struct IfStatementDefaultTypeInternal;
extern IfStatementDefaultTypeInternal _IfStatement_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Operator;
struct OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
class SizedType;
struct SizedTypeDefaultTypeInternal;
extern SizedTypeDefaultTypeInternal _SizedType_default_instance_;
class Statement;
struct StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Uint256;
struct Uint256DefaultTypeInternal;
extern Uint256DefaultTypeInternal _Uint256_default_instance_;
class ValOrOp;
struct ValOrOpDefaultTypeInternal;
extern ValOrOpDefaultTypeInternal _ValOrOp_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class VarDecl;
struct VarDeclDefaultTypeInternal;
extern VarDeclDefaultTypeInternal _VarDecl_default_instance_;
class VyperContract;
struct VyperContractDefaultTypeInternal;
extern VyperContractDefaultTypeInternal _VyperContract_default_instance_;
}  // namespace vyper
PROTOBUF_NAMESPACE_OPEN
template <>
::vyper::ArgDef* Arena::CreateMaybeMessage<::vyper::ArgDef>(Arena*);
template <>
::vyper::Assignment* Arena::CreateMaybeMessage<::vyper::Assignment>(Arena*);
template <>
::vyper::BuiltinCall* Arena::CreateMaybeMessage<::vyper::BuiltinCall>(Arena*);
template <>
::vyper::CodeBlock* Arena::CreateMaybeMessage<::vyper::CodeBlock>(Arena*);
template <>
::vyper::ConcatCall* Arena::CreateMaybeMessage<::vyper::ConcatCall>(Arena*);
template <>
::vyper::ConvertCall* Arena::CreateMaybeMessage<::vyper::ConvertCall>(Arena*);
template <>
::vyper::FunctionCall* Arena::CreateMaybeMessage<::vyper::FunctionCall>(Arena*);
template <>
::vyper::FunctionDef* Arena::CreateMaybeMessage<::vyper::FunctionDef>(Arena*);
template <>
::vyper::IfStatement* Arena::CreateMaybeMessage<::vyper::IfStatement>(Arena*);
template <>
::vyper::Operation* Arena::CreateMaybeMessage<::vyper::Operation>(Arena*);
template <>
::vyper::Operator* Arena::CreateMaybeMessage<::vyper::Operator>(Arena*);
template <>
::vyper::SizedType* Arena::CreateMaybeMessage<::vyper::SizedType>(Arena*);
template <>
::vyper::Statement* Arena::CreateMaybeMessage<::vyper::Statement>(Arena*);
template <>
::vyper::Type* Arena::CreateMaybeMessage<::vyper::Type>(Arena*);
template <>
::vyper::Uint256* Arena::CreateMaybeMessage<::vyper::Uint256>(Arena*);
template <>
::vyper::ValOrOp* Arena::CreateMaybeMessage<::vyper::ValOrOp>(Arena*);
template <>
::vyper::Value* Arena::CreateMaybeMessage<::vyper::Value>(Arena*);
template <>
::vyper::VarDecl* Arena::CreateMaybeMessage<::vyper::VarDecl>(Arena*);
template <>
::vyper::VyperContract* Arena::CreateMaybeMessage<::vyper::VyperContract>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace vyper {
enum Operator_OPERATOR : int {
  Operator_OPERATOR_PLUS = 0,
  Operator_OPERATOR_MINUS = 1,
  Operator_OPERATOR_TIMES = 2,
  Operator_OPERATOR_MOD = 3,
  Operator_OPERATOR_Operator_OPERATOR_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Operator_OPERATOR_Operator_OPERATOR_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Operator_OPERATOR_IsValid(int value);
constexpr Operator_OPERATOR Operator_OPERATOR_OPERATOR_MIN = static_cast<Operator_OPERATOR>(0);
constexpr Operator_OPERATOR Operator_OPERATOR_OPERATOR_MAX = static_cast<Operator_OPERATOR>(3);
constexpr int Operator_OPERATOR_OPERATOR_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Operator_OPERATOR_descriptor();
template <typename T>
const std::string& Operator_OPERATOR_Name(T value) {
  static_assert(std::is_same<T, Operator_OPERATOR>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OPERATOR_Name().");
  return Operator_OPERATOR_Name(static_cast<Operator_OPERATOR>(value));
}
template <>
inline const std::string& Operator_OPERATOR_Name(Operator_OPERATOR value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Operator_OPERATOR_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Operator_OPERATOR_Parse(absl::string_view name, Operator_OPERATOR* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Operator_OPERATOR>(
      Operator_OPERATOR_descriptor(), name, value);
}
enum TYPE_ENUM : int {
  uint256 = 0,
  int256 = 1,
  int64 = 2,
  bytes32 = 3,
  TYPE_ENUM_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TYPE_ENUM_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TYPE_ENUM_IsValid(int value);
constexpr TYPE_ENUM TYPE_ENUM_MIN = static_cast<TYPE_ENUM>(0);
constexpr TYPE_ENUM TYPE_ENUM_MAX = static_cast<TYPE_ENUM>(3);
constexpr int TYPE_ENUM_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TYPE_ENUM_descriptor();
template <typename T>
const std::string& TYPE_ENUM_Name(T value) {
  static_assert(std::is_same<T, TYPE_ENUM>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TYPE_ENUM_Name().");
  return TYPE_ENUM_Name(static_cast<TYPE_ENUM>(value));
}
template <>
inline const std::string& TYPE_ENUM_Name(TYPE_ENUM value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TYPE_ENUM_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TYPE_ENUM_Parse(absl::string_view name, TYPE_ENUM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TYPE_ENUM>(
      TYPE_ENUM_descriptor(), name, value);
}
enum SIZED_TYPE_ENUM : int {
  String = 0,
  SIZED_TYPE_ENUM_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SIZED_TYPE_ENUM_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SIZED_TYPE_ENUM_IsValid(int value);
constexpr SIZED_TYPE_ENUM SIZED_TYPE_ENUM_MIN = static_cast<SIZED_TYPE_ENUM>(0);
constexpr SIZED_TYPE_ENUM SIZED_TYPE_ENUM_MAX = static_cast<SIZED_TYPE_ENUM>(0);
constexpr int SIZED_TYPE_ENUM_ARRAYSIZE = 0 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SIZED_TYPE_ENUM_descriptor();
template <typename T>
const std::string& SIZED_TYPE_ENUM_Name(T value) {
  static_assert(std::is_same<T, SIZED_TYPE_ENUM>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SIZED_TYPE_ENUM_Name().");
  return SIZED_TYPE_ENUM_Name(static_cast<SIZED_TYPE_ENUM>(value));
}
template <>
inline const std::string& SIZED_TYPE_ENUM_Name(SIZED_TYPE_ENUM value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SIZED_TYPE_ENUM_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool SIZED_TYPE_ENUM_Parse(absl::string_view name, SIZED_TYPE_ENUM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SIZED_TYPE_ENUM>(
      SIZED_TYPE_ENUM_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Statement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {}
  ~Statement() override;
  explicit PROTOBUF_CONSTEXPR Statement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statement(const Statement& from);
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement& default_instance() {
    return *internal_default_instance();
  }
  enum StatementCase {
    kAssignment = 1,
    kIfStatement = 2,
    kFunctionCall = 3,
    kBuiltinCall = 4,
    kDecl = 5,
    kReturn = 6,
    STATEMENT_NOT_SET = 0,
  };

  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }
  inline void Swap(Statement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Statement& from) {
    Statement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Statement";
  }
  protected:
  explicit Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentFieldNumber = 1,
    kIfStatementFieldNumber = 2,
    kFunctionCallFieldNumber = 3,
    kBuiltinCallFieldNumber = 4,
    kDeclFieldNumber = 5,
    kReturnFieldNumber = 6,
  };
  // .vyper.Assignment assignment = 1;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;

  public:
  void clear_assignment() ;
  const ::vyper::Assignment& assignment() const;
  PROTOBUF_NODISCARD ::vyper::Assignment* release_assignment();
  ::vyper::Assignment* mutable_assignment();
  void set_allocated_assignment(::vyper::Assignment* assignment);
  private:
  const ::vyper::Assignment& _internal_assignment() const;
  ::vyper::Assignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::vyper::Assignment* assignment);
  ::vyper::Assignment* unsafe_arena_release_assignment();
  // .vyper.IfStatement if_statement = 2;
  bool has_if_statement() const;
  private:
  bool _internal_has_if_statement() const;

  public:
  void clear_if_statement() ;
  const ::vyper::IfStatement& if_statement() const;
  PROTOBUF_NODISCARD ::vyper::IfStatement* release_if_statement();
  ::vyper::IfStatement* mutable_if_statement();
  void set_allocated_if_statement(::vyper::IfStatement* if_statement);
  private:
  const ::vyper::IfStatement& _internal_if_statement() const;
  ::vyper::IfStatement* _internal_mutable_if_statement();
  public:
  void unsafe_arena_set_allocated_if_statement(
      ::vyper::IfStatement* if_statement);
  ::vyper::IfStatement* unsafe_arena_release_if_statement();
  // .vyper.FunctionCall function_call = 3;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;

  public:
  void clear_function_call() ;
  const ::vyper::FunctionCall& function_call() const;
  PROTOBUF_NODISCARD ::vyper::FunctionCall* release_function_call();
  ::vyper::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::vyper::FunctionCall* function_call);
  private:
  const ::vyper::FunctionCall& _internal_function_call() const;
  ::vyper::FunctionCall* _internal_mutable_function_call();
  public:
  void unsafe_arena_set_allocated_function_call(
      ::vyper::FunctionCall* function_call);
  ::vyper::FunctionCall* unsafe_arena_release_function_call();
  // .vyper.BuiltinCall builtin_call = 4;
  bool has_builtin_call() const;
  private:
  bool _internal_has_builtin_call() const;

  public:
  void clear_builtin_call() ;
  const ::vyper::BuiltinCall& builtin_call() const;
  PROTOBUF_NODISCARD ::vyper::BuiltinCall* release_builtin_call();
  ::vyper::BuiltinCall* mutable_builtin_call();
  void set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call);
  private:
  const ::vyper::BuiltinCall& _internal_builtin_call() const;
  ::vyper::BuiltinCall* _internal_mutable_builtin_call();
  public:
  void unsafe_arena_set_allocated_builtin_call(
      ::vyper::BuiltinCall* builtin_call);
  ::vyper::BuiltinCall* unsafe_arena_release_builtin_call();
  // .vyper.VarDecl decl = 5;
  bool has_decl() const;
  private:
  bool _internal_has_decl() const;

  public:
  void clear_decl() ;
  const ::vyper::VarDecl& decl() const;
  PROTOBUF_NODISCARD ::vyper::VarDecl* release_decl();
  ::vyper::VarDecl* mutable_decl();
  void set_allocated_decl(::vyper::VarDecl* decl);
  private:
  const ::vyper::VarDecl& _internal_decl() const;
  ::vyper::VarDecl* _internal_mutable_decl();
  public:
  void unsafe_arena_set_allocated_decl(
      ::vyper::VarDecl* decl);
  ::vyper::VarDecl* unsafe_arena_release_decl();
  // .vyper.ValOrOp return = 6;
  bool has_return_() const;
  private:
  bool _internal_has_return_() const;

  public:
  void clear_return_() ;
  const ::vyper::ValOrOp& return_() const;
  PROTOBUF_NODISCARD ::vyper::ValOrOp* release_return_();
  ::vyper::ValOrOp* mutable_return_();
  void set_allocated_return_(::vyper::ValOrOp* return_);
  private:
  const ::vyper::ValOrOp& _internal_return_() const;
  ::vyper::ValOrOp* _internal_mutable_return_();
  public:
  void unsafe_arena_set_allocated_return_(
      ::vyper::ValOrOp* return_);
  ::vyper::ValOrOp* unsafe_arena_release_return_();
  void clear_statement();
  StatementCase statement_case() const;
  // @@protoc_insertion_point(class_scope:vyper.Statement)
 private:
  class _Internal;
  void set_has_assignment();
  void set_has_if_statement();
  void set_has_function_call();
  void set_has_builtin_call();
  void set_has_decl();
  void set_has_return_();

  inline bool has_statement() const;
  inline void clear_has_statement();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StatementUnion {
      constexpr StatementUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::Assignment* assignment_;
      ::vyper::IfStatement* if_statement_;
      ::vyper::FunctionCall* function_call_;
      ::vyper::BuiltinCall* builtin_call_;
      ::vyper::VarDecl* decl_;
      ::vyper::ValOrOp* return__;
    } statement_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Uint256 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Uint256) */ {
 public:
  inline Uint256() : Uint256(nullptr) {}
  ~Uint256() override;
  explicit PROTOBUF_CONSTEXPR Uint256(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint256(const Uint256& from);
  Uint256(Uint256&& from) noexcept
    : Uint256() {
    *this = ::std::move(from);
  }

  inline Uint256& operator=(const Uint256& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint256& operator=(Uint256&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint256& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint256* internal_default_instance() {
    return reinterpret_cast<const Uint256*>(
               &_Uint256_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Uint256& a, Uint256& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint256* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint256* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint256* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint256>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint256& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint256& from) {
    Uint256::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint256* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Uint256";
  }
  protected:
  explicit Uint256(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHbFieldNumber = 1,
    kLbFieldNumber = 2,
  };
  // uint64 hb = 1;
  void clear_hb() ;
  ::uint64_t hb() const;
  void set_hb(::uint64_t value);

  private:
  ::uint64_t _internal_hb() const;
  void _internal_set_hb(::uint64_t value);

  public:
  // uint64 lb = 2;
  void clear_lb() ;
  ::uint64_t lb() const;
  void set_lb(::uint64_t value);

  private:
  ::uint64_t _internal_lb() const;
  void _internal_set_lb(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:vyper.Uint256)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t hb_;
    ::uint64_t lb_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStrLiteral = 1,
    kVarName = 2,
    kNum = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrLiteralFieldNumber = 1,
    kVarNameFieldNumber = 2,
    kNumFieldNumber = 3,
  };
  // string str_literal = 1;
  bool has_str_literal() const;
  void clear_str_literal() ;
  const std::string& str_literal() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_str_literal(Arg_&& arg, Args_... args);
  std::string* mutable_str_literal();
  PROTOBUF_NODISCARD std::string* release_str_literal();
  void set_allocated_str_literal(std::string* ptr);

  private:
  const std::string& _internal_str_literal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_literal(
      const std::string& value);
  std::string* _internal_mutable_str_literal();

  public:
  // string var_name = 2;
  bool has_var_name() const;
  void clear_var_name() ;
  const std::string& var_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_var_name(Arg_&& arg, Args_... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* ptr);

  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(
      const std::string& value);
  std::string* _internal_mutable_var_name();

  public:
  // .vyper.Uint256 num = 3;
  bool has_num() const;
  private:
  bool _internal_has_num() const;

  public:
  void clear_num() ;
  const ::vyper::Uint256& num() const;
  PROTOBUF_NODISCARD ::vyper::Uint256* release_num();
  ::vyper::Uint256* mutable_num();
  void set_allocated_num(::vyper::Uint256* num);
  private:
  const ::vyper::Uint256& _internal_num() const;
  ::vyper::Uint256* _internal_mutable_num();
  public:
  void unsafe_arena_set_allocated_num(
      ::vyper::Uint256* num);
  ::vyper::Uint256* unsafe_arena_release_num();
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:vyper.Value)
 private:
  class _Internal;
  void set_has_str_literal();
  void set_has_var_name();
  void set_has_num();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_literal_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
      ::vyper::Uint256* num_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Operator final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vyper.Operator) */ {
 public:
  inline Operator() : Operator(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Operator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operator(const Operator& from);
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operator& operator=(Operator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }
  inline void Swap(Operator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Operator& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Operator& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Operator";
  }
  protected:
  explicit Operator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using OPERATOR = Operator_OPERATOR;
  static constexpr OPERATOR PLUS = Operator_OPERATOR_PLUS;
  static constexpr OPERATOR MINUS = Operator_OPERATOR_MINUS;
  static constexpr OPERATOR TIMES = Operator_OPERATOR_TIMES;
  static constexpr OPERATOR MOD = Operator_OPERATOR_MOD;
  static inline bool OPERATOR_IsValid(int value) {
    return Operator_OPERATOR_IsValid(value);
  }
  static constexpr OPERATOR OPERATOR_MIN = Operator_OPERATOR_OPERATOR_MIN;
  static constexpr OPERATOR OPERATOR_MAX = Operator_OPERATOR_OPERATOR_MAX;
  static constexpr int OPERATOR_ARRAYSIZE = Operator_OPERATOR_OPERATOR_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OPERATOR_descriptor() {
    return Operator_OPERATOR_descriptor();
  }
  template <typename T>
  static inline const std::string& OPERATOR_Name(T value) {
    return Operator_OPERATOR_Name(value);
  }
  static inline bool OPERATOR_Parse(absl::string_view name, OPERATOR* value) {
    return Operator_OPERATOR_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vyper.Operator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVal1FieldNumber = 1,
    kVal2FieldNumber = 2,
    kOperatorFieldNumber = 3,
  };
  // .vyper.Value val1 = 1;
  bool has_val1() const;
  private:
  bool _internal_has_val1() const;

  public:
  void clear_val1() ;
  const ::vyper::Value& val1() const;
  PROTOBUF_NODISCARD ::vyper::Value* release_val1();
  ::vyper::Value* mutable_val1();
  void set_allocated_val1(::vyper::Value* val1);
  private:
  const ::vyper::Value& _internal_val1() const;
  ::vyper::Value* _internal_mutable_val1();
  public:
  void unsafe_arena_set_allocated_val1(
      ::vyper::Value* val1);
  ::vyper::Value* unsafe_arena_release_val1();
  // .vyper.Value val2 = 2;
  bool has_val2() const;
  private:
  bool _internal_has_val2() const;

  public:
  void clear_val2() ;
  const ::vyper::Value& val2() const;
  PROTOBUF_NODISCARD ::vyper::Value* release_val2();
  ::vyper::Value* mutable_val2();
  void set_allocated_val2(::vyper::Value* val2);
  private:
  const ::vyper::Value& _internal_val2() const;
  ::vyper::Value* _internal_mutable_val2();
  public:
  void unsafe_arena_set_allocated_val2(
      ::vyper::Value* val2);
  ::vyper::Value* unsafe_arena_release_val2();
  // .vyper.Operator operator = 3;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;

  public:
  void clear_operator_() ;
  const ::vyper::Operator& operator_() const;
  PROTOBUF_NODISCARD ::vyper::Operator* release_operator_();
  ::vyper::Operator* mutable_operator_();
  void set_allocated_operator_(::vyper::Operator* operator_);
  private:
  const ::vyper::Operator& _internal_operator_() const;
  ::vyper::Operator* _internal_mutable_operator_();
  public:
  void unsafe_arena_set_allocated_operator_(
      ::vyper::Operator* operator_);
  ::vyper::Operator* unsafe_arena_release_operator_();
  // @@protoc_insertion_point(class_scope:vyper.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vyper::Value* val1_;
    ::vyper::Value* val2_;
    ::vyper::Operator* operator__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class VarDecl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.VarDecl) */ {
 public:
  inline VarDecl() : VarDecl(nullptr) {}
  ~VarDecl() override;
  explicit PROTOBUF_CONSTEXPR VarDecl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarDecl(const VarDecl& from);
  VarDecl(VarDecl&& from) noexcept
    : VarDecl() {
    *this = ::std::move(from);
  }

  inline VarDecl& operator=(const VarDecl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarDecl& operator=(VarDecl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarDecl& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kType = 2,
    kStype = 3,
    _TYPE_NOT_SET = 0,
  };

  static inline const VarDecl* internal_default_instance() {
    return reinterpret_cast<const VarDecl*>(
               &_VarDecl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VarDecl& a, VarDecl& b) {
    a.Swap(&b);
  }
  inline void Swap(VarDecl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarDecl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarDecl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarDecl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarDecl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarDecl& from) {
    VarDecl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDecl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.VarDecl";
  }
  protected:
  explicit VarDecl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarNameFieldNumber = 1,
    kValFieldNumber = 4,
    kTypeFieldNumber = 2,
    kStypeFieldNumber = 3,
  };
  // string var_name = 1;
  void clear_var_name() ;
  const std::string& var_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_var_name(Arg_&& arg, Args_... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* ptr);

  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(
      const std::string& value);
  std::string* _internal_mutable_var_name();

  public:
  // optional .vyper.ValOrOp val = 4;
  bool has_val() const;
  void clear_val() ;
  const ::vyper::ValOrOp& val() const;
  PROTOBUF_NODISCARD ::vyper::ValOrOp* release_val();
  ::vyper::ValOrOp* mutable_val();
  void set_allocated_val(::vyper::ValOrOp* val);
  private:
  const ::vyper::ValOrOp& _internal_val() const;
  ::vyper::ValOrOp* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::vyper::ValOrOp* val);
  ::vyper::ValOrOp* unsafe_arena_release_val();
  // .vyper.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;

  public:
  void clear_type() ;
  const ::vyper::Type& type() const;
  PROTOBUF_NODISCARD ::vyper::Type* release_type();
  ::vyper::Type* mutable_type();
  void set_allocated_type(::vyper::Type* type);
  private:
  const ::vyper::Type& _internal_type() const;
  ::vyper::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::vyper::Type* type);
  ::vyper::Type* unsafe_arena_release_type();
  // .vyper.SizedType stype = 3;
  bool has_stype() const;
  private:
  bool _internal_has_stype() const;

  public:
  void clear_stype() ;
  const ::vyper::SizedType& stype() const;
  PROTOBUF_NODISCARD ::vyper::SizedType* release_stype();
  ::vyper::SizedType* mutable_stype();
  void set_allocated_stype(::vyper::SizedType* stype);
  private:
  const ::vyper::SizedType& _internal_stype() const;
  ::vyper::SizedType* _internal_mutable_stype();
  public:
  void unsafe_arena_set_allocated_stype(
      ::vyper::SizedType* stype);
  ::vyper::SizedType* unsafe_arena_release_stype();
  void clear__type();
  TypeCase _type_case() const;
  // @@protoc_insertion_point(class_scope:vyper.VarDecl)
 private:
  class _Internal;
  void set_has_type();
  void set_has_stype();

  inline bool has__type() const;
  inline void clear_has__type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    ::vyper::ValOrOp* val_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::Type* type_;
      ::vyper::SizedType* stype_;
    } _type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class ValOrOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ValOrOp) */ {
 public:
  inline ValOrOp() : ValOrOp(nullptr) {}
  ~ValOrOp() override;
  explicit PROTOBUF_CONSTEXPR ValOrOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValOrOp(const ValOrOp& from);
  ValOrOp(ValOrOp&& from) noexcept
    : ValOrOp() {
    *this = ::std::move(from);
  }

  inline ValOrOp& operator=(const ValOrOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValOrOp& operator=(ValOrOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValOrOp& default_instance() {
    return *internal_default_instance();
  }
  enum ValueOrOpCase {
    kVal = 1,
    kOp = 2,
    kFuncCall = 3,
    kBuiltinCall = 4,
    VALUE_OR_OP_NOT_SET = 0,
  };

  static inline const ValOrOp* internal_default_instance() {
    return reinterpret_cast<const ValOrOp*>(
               &_ValOrOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ValOrOp& a, ValOrOp& b) {
    a.Swap(&b);
  }
  inline void Swap(ValOrOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValOrOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValOrOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValOrOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValOrOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValOrOp& from) {
    ValOrOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValOrOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.ValOrOp";
  }
  protected:
  explicit ValOrOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
    kOpFieldNumber = 2,
    kFuncCallFieldNumber = 3,
    kBuiltinCallFieldNumber = 4,
  };
  // .vyper.Value val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;

  public:
  void clear_val() ;
  const ::vyper::Value& val() const;
  PROTOBUF_NODISCARD ::vyper::Value* release_val();
  ::vyper::Value* mutable_val();
  void set_allocated_val(::vyper::Value* val);
  private:
  const ::vyper::Value& _internal_val() const;
  ::vyper::Value* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::vyper::Value* val);
  ::vyper::Value* unsafe_arena_release_val();
  // .vyper.Operation op = 2;
  bool has_op() const;
  private:
  bool _internal_has_op() const;

  public:
  void clear_op() ;
  const ::vyper::Operation& op() const;
  PROTOBUF_NODISCARD ::vyper::Operation* release_op();
  ::vyper::Operation* mutable_op();
  void set_allocated_op(::vyper::Operation* op);
  private:
  const ::vyper::Operation& _internal_op() const;
  ::vyper::Operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::vyper::Operation* op);
  ::vyper::Operation* unsafe_arena_release_op();
  // .vyper.FunctionCall func_call = 3;
  bool has_func_call() const;
  private:
  bool _internal_has_func_call() const;

  public:
  void clear_func_call() ;
  const ::vyper::FunctionCall& func_call() const;
  PROTOBUF_NODISCARD ::vyper::FunctionCall* release_func_call();
  ::vyper::FunctionCall* mutable_func_call();
  void set_allocated_func_call(::vyper::FunctionCall* func_call);
  private:
  const ::vyper::FunctionCall& _internal_func_call() const;
  ::vyper::FunctionCall* _internal_mutable_func_call();
  public:
  void unsafe_arena_set_allocated_func_call(
      ::vyper::FunctionCall* func_call);
  ::vyper::FunctionCall* unsafe_arena_release_func_call();
  // .vyper.BuiltinCall builtin_call = 4;
  bool has_builtin_call() const;
  private:
  bool _internal_has_builtin_call() const;

  public:
  void clear_builtin_call() ;
  const ::vyper::BuiltinCall& builtin_call() const;
  PROTOBUF_NODISCARD ::vyper::BuiltinCall* release_builtin_call();
  ::vyper::BuiltinCall* mutable_builtin_call();
  void set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call);
  private:
  const ::vyper::BuiltinCall& _internal_builtin_call() const;
  ::vyper::BuiltinCall* _internal_mutable_builtin_call();
  public:
  void unsafe_arena_set_allocated_builtin_call(
      ::vyper::BuiltinCall* builtin_call);
  ::vyper::BuiltinCall* unsafe_arena_release_builtin_call();
  void clear_value_or_op();
  ValueOrOpCase value_or_op_case() const;
  // @@protoc_insertion_point(class_scope:vyper.ValOrOp)
 private:
  class _Internal;
  void set_has_val();
  void set_has_op();
  void set_has_func_call();
  void set_has_builtin_call();

  inline bool has_value_or_op() const;
  inline void clear_has_value_or_op();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueOrOpUnion {
      constexpr ValueOrOpUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::Value* val_;
      ::vyper::Operation* op_;
      ::vyper::FunctionCall* func_call_;
      ::vyper::BuiltinCall* builtin_call_;
    } value_or_op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class CodeBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.CodeBlock) */ {
 public:
  inline CodeBlock() : CodeBlock(nullptr) {}
  ~CodeBlock() override;
  explicit PROTOBUF_CONSTEXPR CodeBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CodeBlock(const CodeBlock& from);
  CodeBlock(CodeBlock&& from) noexcept
    : CodeBlock() {
    *this = ::std::move(from);
  }

  inline CodeBlock& operator=(const CodeBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeBlock& operator=(CodeBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodeBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodeBlock* internal_default_instance() {
    return reinterpret_cast<const CodeBlock*>(
               &_CodeBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CodeBlock& a, CodeBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(CodeBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeBlock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodeBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CodeBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CodeBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CodeBlock& from) {
    CodeBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodeBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.CodeBlock";
  }
  protected:
  explicit CodeBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated .vyper.Statement statements = 1;
  int statements_size() const;
  private:
  int _internal_statements_size() const;

  public:
  void clear_statements() ;
  ::vyper::Statement* mutable_statements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >*
      mutable_statements();
  private:
  const ::vyper::Statement& _internal_statements(int index) const;
  ::vyper::Statement* _internal_add_statements();
  public:
  const ::vyper::Statement& statements(int index) const;
  ::vyper::Statement* add_statements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >&
      statements() const;
  // @@protoc_insertion_point(class_scope:vyper.CodeBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement > statements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class ArgDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ArgDef) */ {
 public:
  inline ArgDef() : ArgDef(nullptr) {}
  ~ArgDef() override;
  explicit PROTOBUF_CONSTEXPR ArgDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArgDef(const ArgDef& from);
  ArgDef(ArgDef&& from) noexcept
    : ArgDef() {
    *this = ::std::move(from);
  }

  inline ArgDef& operator=(const ArgDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArgDef& operator=(ArgDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArgDef& default_instance() {
    return *internal_default_instance();
  }
  enum ArgCase {
    kStype = 1,
    kType = 2,
    ARG_NOT_SET = 0,
  };

  static inline const ArgDef* internal_default_instance() {
    return reinterpret_cast<const ArgDef*>(
               &_ArgDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ArgDef& a, ArgDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ArgDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArgDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArgDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArgDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArgDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArgDef& from) {
    ArgDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArgDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.ArgDef";
  }
  protected:
  explicit ArgDef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgNameFieldNumber = 3,
    kStypeFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string arg_name = 3;
  void clear_arg_name() ;
  const std::string& arg_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_arg_name(Arg_&& arg, Args_... args);
  std::string* mutable_arg_name();
  PROTOBUF_NODISCARD std::string* release_arg_name();
  void set_allocated_arg_name(std::string* ptr);

  private:
  const std::string& _internal_arg_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg_name(
      const std::string& value);
  std::string* _internal_mutable_arg_name();

  public:
  // .vyper.SizedType stype = 1;
  bool has_stype() const;
  private:
  bool _internal_has_stype() const;

  public:
  void clear_stype() ;
  const ::vyper::SizedType& stype() const;
  PROTOBUF_NODISCARD ::vyper::SizedType* release_stype();
  ::vyper::SizedType* mutable_stype();
  void set_allocated_stype(::vyper::SizedType* stype);
  private:
  const ::vyper::SizedType& _internal_stype() const;
  ::vyper::SizedType* _internal_mutable_stype();
  public:
  void unsafe_arena_set_allocated_stype(
      ::vyper::SizedType* stype);
  ::vyper::SizedType* unsafe_arena_release_stype();
  // .vyper.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;

  public:
  void clear_type() ;
  const ::vyper::Type& type() const;
  PROTOBUF_NODISCARD ::vyper::Type* release_type();
  ::vyper::Type* mutable_type();
  void set_allocated_type(::vyper::Type* type);
  private:
  const ::vyper::Type& _internal_type() const;
  ::vyper::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::vyper::Type* type);
  ::vyper::Type* unsafe_arena_release_type();
  void clear_arg();
  ArgCase arg_case() const;
  // @@protoc_insertion_point(class_scope:vyper.ArgDef)
 private:
  class _Internal;
  void set_has_stype();
  void set_has_type();

  inline bool has_arg() const;
  inline void clear_has_arg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg_name_;
    union ArgUnion {
      constexpr ArgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::SizedType* stype_;
      ::vyper::Type* type_;
    } arg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class FunctionDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.FunctionDef) */ {
 public:
  inline FunctionDef() : FunctionDef(nullptr) {}
  ~FunctionDef() override;
  explicit PROTOBUF_CONSTEXPR FunctionDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionDef(const FunctionDef& from);
  FunctionDef(FunctionDef&& from) noexcept
    : FunctionDef() {
    *this = ::std::move(from);
  }

  inline FunctionDef& operator=(const FunctionDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionDef& operator=(FunctionDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionDef& default_instance() {
    return *internal_default_instance();
  }
  enum RetTypeCase {
    kReturnType = 5,
    kReturnStype = 6,
    RET_TYPE_NOT_SET = 0,
  };

  static inline const FunctionDef* internal_default_instance() {
    return reinterpret_cast<const FunctionDef*>(
               &_FunctionDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FunctionDef& a, FunctionDef& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionDef& from) {
    FunctionDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.FunctionDef";
  }
  protected:
  explicit FunctionDef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionNameFieldNumber = 1,
    kBlockFieldNumber = 3,
    kExternalFieldNumber = 4,
    kReturnTypeFieldNumber = 5,
    kReturnStypeFieldNumber = 6,
  };
  // repeated .vyper.ArgDef args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  ::vyper::ArgDef* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >*
      mutable_args();
  private:
  const ::vyper::ArgDef& _internal_args(int index) const;
  ::vyper::ArgDef* _internal_add_args();
  public:
  const ::vyper::ArgDef& args(int index) const;
  ::vyper::ArgDef* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >&
      args() const;
  // string function_name = 1;
  void clear_function_name() ;
  const std::string& function_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_function_name(Arg_&& arg, Args_... args);
  std::string* mutable_function_name();
  PROTOBUF_NODISCARD std::string* release_function_name();
  void set_allocated_function_name(std::string* ptr);

  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(
      const std::string& value);
  std::string* _internal_mutable_function_name();

  public:
  // .vyper.CodeBlock block = 3;
  bool has_block() const;
  private:
  bool _internal_has_block() const;

  public:
  void clear_block() ;
  const ::vyper::CodeBlock& block() const;
  PROTOBUF_NODISCARD ::vyper::CodeBlock* release_block();
  ::vyper::CodeBlock* mutable_block();
  void set_allocated_block(::vyper::CodeBlock* block);
  private:
  const ::vyper::CodeBlock& _internal_block() const;
  ::vyper::CodeBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::vyper::CodeBlock* block);
  ::vyper::CodeBlock* unsafe_arena_release_block();
  // bool external = 4;
  void clear_external() ;
  bool external() const;
  void set_external(bool value);

  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);

  public:
  // .vyper.Type return_type = 5;
  bool has_return_type() const;
  private:
  bool _internal_has_return_type() const;

  public:
  void clear_return_type() ;
  const ::vyper::Type& return_type() const;
  PROTOBUF_NODISCARD ::vyper::Type* release_return_type();
  ::vyper::Type* mutable_return_type();
  void set_allocated_return_type(::vyper::Type* return_type);
  private:
  const ::vyper::Type& _internal_return_type() const;
  ::vyper::Type* _internal_mutable_return_type();
  public:
  void unsafe_arena_set_allocated_return_type(
      ::vyper::Type* return_type);
  ::vyper::Type* unsafe_arena_release_return_type();
  // .vyper.SizedType return_stype = 6;
  bool has_return_stype() const;
  private:
  bool _internal_has_return_stype() const;

  public:
  void clear_return_stype() ;
  const ::vyper::SizedType& return_stype() const;
  PROTOBUF_NODISCARD ::vyper::SizedType* release_return_stype();
  ::vyper::SizedType* mutable_return_stype();
  void set_allocated_return_stype(::vyper::SizedType* return_stype);
  private:
  const ::vyper::SizedType& _internal_return_stype() const;
  ::vyper::SizedType* _internal_mutable_return_stype();
  public:
  void unsafe_arena_set_allocated_return_stype(
      ::vyper::SizedType* return_stype);
  ::vyper::SizedType* unsafe_arena_release_return_stype();
  void clear_ret_type();
  RetTypeCase ret_type_case() const;
  // @@protoc_insertion_point(class_scope:vyper.FunctionDef)
 private:
  class _Internal;
  void set_has_return_type();
  void set_has_return_stype();

  inline bool has_ret_type() const;
  inline void clear_has_ret_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
    ::vyper::CodeBlock* block_;
    bool external_;
    union RetTypeUnion {
      constexpr RetTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::Type* return_type_;
      ::vyper::SizedType* return_stype_;
    } ret_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit PROTOBUF_CONSTEXPR Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Type& from) {
    Type::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeValFieldNumber = 1,
  };
  // .vyper.TYPE_ENUM typeVal = 1;
  void clear_typeval() ;
  ::vyper::TYPE_ENUM typeval() const;
  void set_typeval(::vyper::TYPE_ENUM value);

  private:
  ::vyper::TYPE_ENUM _internal_typeval() const;
  void _internal_set_typeval(::vyper::TYPE_ENUM value);

  public:
  // @@protoc_insertion_point(class_scope:vyper.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int typeval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class SizedType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.SizedType) */ {
 public:
  inline SizedType() : SizedType(nullptr) {}
  ~SizedType() override;
  explicit PROTOBUF_CONSTEXPR SizedType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SizedType(const SizedType& from);
  SizedType(SizedType&& from) noexcept
    : SizedType() {
    *this = ::std::move(from);
  }

  inline SizedType& operator=(const SizedType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SizedType& operator=(SizedType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SizedType& default_instance() {
    return *internal_default_instance();
  }
  static inline const SizedType* internal_default_instance() {
    return reinterpret_cast<const SizedType*>(
               &_SizedType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SizedType& a, SizedType& b) {
    a.Swap(&b);
  }
  inline void Swap(SizedType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SizedType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SizedType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SizedType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SizedType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SizedType& from) {
    SizedType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SizedType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.SizedType";
  }
  protected:
  explicit SizedType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeValFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .vyper.SIZED_TYPE_ENUM typeVal = 1;
  void clear_typeval() ;
  ::vyper::SIZED_TYPE_ENUM typeval() const;
  void set_typeval(::vyper::SIZED_TYPE_ENUM value);

  private:
  ::vyper::SIZED_TYPE_ENUM _internal_typeval() const;
  void _internal_set_typeval(::vyper::SIZED_TYPE_ENUM value);

  public:
  // uint32 size = 2;
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:vyper.SizedType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int typeval_;
    ::uint32_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class Assignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.Assignment) */ {
 public:
  inline Assignment() : Assignment(nullptr) {}
  ~Assignment() override;
  explicit PROTOBUF_CONSTEXPR Assignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assignment(const Assignment& from);
  Assignment(Assignment&& from) noexcept
    : Assignment() {
    *this = ::std::move(from);
  }

  inline Assignment& operator=(const Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assignment& operator=(Assignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assignment& default_instance() {
    return *internal_default_instance();
  }
  enum VarCase {
    kVariableName = 1,
    kDecl = 2,
    VAR_NOT_SET = 0,
  };

  static inline const Assignment* internal_default_instance() {
    return reinterpret_cast<const Assignment*>(
               &_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Assignment& a, Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(Assignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assignment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Assignment& from) {
    Assignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.Assignment";
  }
  protected:
  explicit Assignment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kVariableNameFieldNumber = 1,
    kDeclFieldNumber = 2,
  };
  // .vyper.ValOrOp value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;

  public:
  void clear_value() ;
  const ::vyper::ValOrOp& value() const;
  PROTOBUF_NODISCARD ::vyper::ValOrOp* release_value();
  ::vyper::ValOrOp* mutable_value();
  void set_allocated_value(::vyper::ValOrOp* value);
  private:
  const ::vyper::ValOrOp& _internal_value() const;
  ::vyper::ValOrOp* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::vyper::ValOrOp* value);
  ::vyper::ValOrOp* unsafe_arena_release_value();
  // string variable_name = 1;
  bool has_variable_name() const;
  void clear_variable_name() ;
  const std::string& variable_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_variable_name(Arg_&& arg, Args_... args);
  std::string* mutable_variable_name();
  PROTOBUF_NODISCARD std::string* release_variable_name();
  void set_allocated_variable_name(std::string* ptr);

  private:
  const std::string& _internal_variable_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable_name(
      const std::string& value);
  std::string* _internal_mutable_variable_name();

  public:
  // .vyper.VarDecl decl = 2;
  bool has_decl() const;
  private:
  bool _internal_has_decl() const;

  public:
  void clear_decl() ;
  const ::vyper::VarDecl& decl() const;
  PROTOBUF_NODISCARD ::vyper::VarDecl* release_decl();
  ::vyper::VarDecl* mutable_decl();
  void set_allocated_decl(::vyper::VarDecl* decl);
  private:
  const ::vyper::VarDecl& _internal_decl() const;
  ::vyper::VarDecl* _internal_mutable_decl();
  public:
  void unsafe_arena_set_allocated_decl(
      ::vyper::VarDecl* decl);
  ::vyper::VarDecl* unsafe_arena_release_decl();
  void clear_var();
  VarCase var_case() const;
  // @@protoc_insertion_point(class_scope:vyper.Assignment)
 private:
  class _Internal;
  void set_has_variable_name();
  void set_has_decl();

  inline bool has_var() const;
  inline void clear_has_var();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vyper::ValOrOp* value_;
    union VarUnion {
      constexpr VarUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_name_;
      ::vyper::VarDecl* decl_;
    } var_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class IfStatement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.IfStatement) */ {
 public:
  inline IfStatement() : IfStatement(nullptr) {}
  ~IfStatement() override;
  explicit PROTOBUF_CONSTEXPR IfStatement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfStatement(const IfStatement& from);
  IfStatement(IfStatement&& from) noexcept
    : IfStatement() {
    *this = ::std::move(from);
  }

  inline IfStatement& operator=(const IfStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfStatement& operator=(IfStatement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfStatement* internal_default_instance() {
    return reinterpret_cast<const IfStatement*>(
               &_IfStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IfStatement& a, IfStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(IfStatement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfStatement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IfStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IfStatement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfStatement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IfStatement& from) {
    IfStatement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfStatement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.IfStatement";
  }
  protected:
  explicit IfStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 1,
    kBlockFieldNumber = 2,
  };
  // string condition = 1;
  void clear_condition() ;
  const std::string& condition() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_condition(Arg_&& arg, Args_... args);
  std::string* mutable_condition();
  PROTOBUF_NODISCARD std::string* release_condition();
  void set_allocated_condition(std::string* ptr);

  private:
  const std::string& _internal_condition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_condition(
      const std::string& value);
  std::string* _internal_mutable_condition();

  public:
  // .vyper.CodeBlock block = 2;
  bool has_block() const;
  private:
  bool _internal_has_block() const;

  public:
  void clear_block() ;
  const ::vyper::CodeBlock& block() const;
  PROTOBUF_NODISCARD ::vyper::CodeBlock* release_block();
  ::vyper::CodeBlock* mutable_block();
  void set_allocated_block(::vyper::CodeBlock* block);
  private:
  const ::vyper::CodeBlock& _internal_block() const;
  ::vyper::CodeBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::vyper::CodeBlock* block);
  ::vyper::CodeBlock* unsafe_arena_release_block();
  // @@protoc_insertion_point(class_scope:vyper.IfStatement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_;
    ::vyper::CodeBlock* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class FunctionCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.FunctionCall) */ {
 public:
  inline FunctionCall() : FunctionCall(nullptr) {}
  ~FunctionCall() override;
  explicit PROTOBUF_CONSTEXPR FunctionCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionCall(const FunctionCall& from);
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionCall& from) {
    FunctionCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.FunctionCall";
  }
  protected:
  explicit FunctionCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionNameFieldNumber = 1,
    kExternalFieldNumber = 3,
  };
  // repeated .vyper.ValOrOp args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  ::vyper::ValOrOp* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >*
      mutable_args();
  private:
  const ::vyper::ValOrOp& _internal_args(int index) const;
  ::vyper::ValOrOp* _internal_add_args();
  public:
  const ::vyper::ValOrOp& args(int index) const;
  ::vyper::ValOrOp* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >&
      args() const;
  // string function_name = 1;
  void clear_function_name() ;
  const std::string& function_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_function_name(Arg_&& arg, Args_... args);
  std::string* mutable_function_name();
  PROTOBUF_NODISCARD std::string* release_function_name();
  void set_allocated_function_name(std::string* ptr);

  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(
      const std::string& value);
  std::string* _internal_mutable_function_name();

  public:
  // bool external = 3;
  void clear_external() ;
  bool external() const;
  void set_external(bool value);

  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vyper.FunctionCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
    bool external_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class ConcatCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ConcatCall) */ {
 public:
  inline ConcatCall() : ConcatCall(nullptr) {}
  ~ConcatCall() override;
  explicit PROTOBUF_CONSTEXPR ConcatCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConcatCall(const ConcatCall& from);
  ConcatCall(ConcatCall&& from) noexcept
    : ConcatCall() {
    *this = ::std::move(from);
  }

  inline ConcatCall& operator=(const ConcatCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConcatCall& operator=(ConcatCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConcatCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConcatCall* internal_default_instance() {
    return reinterpret_cast<const ConcatCall*>(
               &_ConcatCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ConcatCall& a, ConcatCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ConcatCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConcatCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConcatCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConcatCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConcatCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConcatCall& from) {
    ConcatCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConcatCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.ConcatCall";
  }
  protected:
  explicit ConcatCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
  };
  // repeated string args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, std::size_t size);
  void set_args(int index, absl::string_view value);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, std::size_t size);
  void add_args(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();

  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();

  public:
  // @@protoc_insertion_point(class_scope:vyper.ConcatCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class ConvertCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.ConvertCall) */ {
 public:
  inline ConvertCall() : ConvertCall(nullptr) {}
  ~ConvertCall() override;
  explicit PROTOBUF_CONSTEXPR ConvertCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertCall(const ConvertCall& from);
  ConvertCall(ConvertCall&& from) noexcept
    : ConvertCall() {
    *this = ::std::move(from);
  }

  inline ConvertCall& operator=(const ConvertCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertCall& operator=(ConvertCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvertCall* internal_default_instance() {
    return reinterpret_cast<const ConvertCall*>(
               &_ConvertCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConvertCall& a, ConvertCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertCall& from) {
    ConvertCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.ConvertCall";
  }
  protected:
  explicit ConvertCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // .vyper.ValOrOp value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;

  public:
  void clear_value() ;
  const ::vyper::ValOrOp& value() const;
  PROTOBUF_NODISCARD ::vyper::ValOrOp* release_value();
  ::vyper::ValOrOp* mutable_value();
  void set_allocated_value(::vyper::ValOrOp* value);
  private:
  const ::vyper::ValOrOp& _internal_value() const;
  ::vyper::ValOrOp* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::vyper::ValOrOp* value);
  ::vyper::ValOrOp* unsafe_arena_release_value();
  // .vyper.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;

  public:
  void clear_type() ;
  const ::vyper::Type& type() const;
  PROTOBUF_NODISCARD ::vyper::Type* release_type();
  ::vyper::Type* mutable_type();
  void set_allocated_type(::vyper::Type* type);
  private:
  const ::vyper::Type& _internal_type() const;
  ::vyper::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::vyper::Type* type);
  ::vyper::Type* unsafe_arena_release_type();
  // @@protoc_insertion_point(class_scope:vyper.ConvertCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vyper::ValOrOp* value_;
    ::vyper::Type* type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class BuiltinCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.BuiltinCall) */ {
 public:
  inline BuiltinCall() : BuiltinCall(nullptr) {}
  ~BuiltinCall() override;
  explicit PROTOBUF_CONSTEXPR BuiltinCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuiltinCall(const BuiltinCall& from);
  BuiltinCall(BuiltinCall&& from) noexcept
    : BuiltinCall() {
    *this = ::std::move(from);
  }

  inline BuiltinCall& operator=(const BuiltinCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuiltinCall& operator=(BuiltinCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuiltinCall& default_instance() {
    return *internal_default_instance();
  }
  enum CallCase {
    kConcat = 1,
    kConvert = 2,
    CALL_NOT_SET = 0,
  };

  static inline const BuiltinCall* internal_default_instance() {
    return reinterpret_cast<const BuiltinCall*>(
               &_BuiltinCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BuiltinCall& a, BuiltinCall& b) {
    a.Swap(&b);
  }
  inline void Swap(BuiltinCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuiltinCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuiltinCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuiltinCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuiltinCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuiltinCall& from) {
    BuiltinCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltinCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.BuiltinCall";
  }
  protected:
  explicit BuiltinCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConcatFieldNumber = 1,
    kConvertFieldNumber = 2,
  };
  // .vyper.ConcatCall concat = 1;
  bool has_concat() const;
  private:
  bool _internal_has_concat() const;

  public:
  void clear_concat() ;
  const ::vyper::ConcatCall& concat() const;
  PROTOBUF_NODISCARD ::vyper::ConcatCall* release_concat();
  ::vyper::ConcatCall* mutable_concat();
  void set_allocated_concat(::vyper::ConcatCall* concat);
  private:
  const ::vyper::ConcatCall& _internal_concat() const;
  ::vyper::ConcatCall* _internal_mutable_concat();
  public:
  void unsafe_arena_set_allocated_concat(
      ::vyper::ConcatCall* concat);
  ::vyper::ConcatCall* unsafe_arena_release_concat();
  // .vyper.ConvertCall convert = 2;
  bool has_convert() const;
  private:
  bool _internal_has_convert() const;

  public:
  void clear_convert() ;
  const ::vyper::ConvertCall& convert() const;
  PROTOBUF_NODISCARD ::vyper::ConvertCall* release_convert();
  ::vyper::ConvertCall* mutable_convert();
  void set_allocated_convert(::vyper::ConvertCall* convert);
  private:
  const ::vyper::ConvertCall& _internal_convert() const;
  ::vyper::ConvertCall* _internal_mutable_convert();
  public:
  void unsafe_arena_set_allocated_convert(
      ::vyper::ConvertCall* convert);
  ::vyper::ConvertCall* unsafe_arena_release_convert();
  void clear_call();
  CallCase call_case() const;
  // @@protoc_insertion_point(class_scope:vyper.BuiltinCall)
 private:
  class _Internal;
  void set_has_concat();
  void set_has_convert();

  inline bool has_call() const;
  inline void clear_has_call();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CallUnion {
      constexpr CallUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vyper::ConcatCall* concat_;
      ::vyper::ConvertCall* convert_;
    } call_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};// -------------------------------------------------------------------

class VyperContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vyper.VyperContract) */ {
 public:
  inline VyperContract() : VyperContract(nullptr) {}
  ~VyperContract() override;
  explicit PROTOBUF_CONSTEXPR VyperContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VyperContract(const VyperContract& from);
  VyperContract(VyperContract&& from) noexcept
    : VyperContract() {
    *this = ::std::move(from);
  }

  inline VyperContract& operator=(const VyperContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VyperContract& operator=(VyperContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VyperContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const VyperContract* internal_default_instance() {
    return reinterpret_cast<const VyperContract*>(
               &_VyperContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VyperContract& a, VyperContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VyperContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VyperContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VyperContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VyperContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VyperContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VyperContract& from) {
    VyperContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VyperContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "vyper.VyperContract";
  }
  protected:
  explicit VyperContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionsFieldNumber = 1,
  };
  // repeated .vyper.FunctionDef functions = 1;
  int functions_size() const;
  private:
  int _internal_functions_size() const;

  public:
  void clear_functions() ;
  ::vyper::FunctionDef* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >*
      mutable_functions();
  private:
  const ::vyper::FunctionDef& _internal_functions(int index) const;
  ::vyper::FunctionDef* _internal_add_functions();
  public:
  const ::vyper::FunctionDef& functions(int index) const;
  ::vyper::FunctionDef* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >&
      functions() const;
  // @@protoc_insertion_point(class_scope:vyper.VyperContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef > functions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vyper_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Statement

// .vyper.Assignment assignment = 1;
inline bool Statement::has_assignment() const {
  return statement_case() == kAssignment;
}
inline bool Statement::_internal_has_assignment() const {
  return statement_case() == kAssignment;
}
inline void Statement::set_has_assignment() {
  _impl_._oneof_case_[0] = kAssignment;
}
inline void Statement::clear_assignment() {
  if (statement_case() == kAssignment) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.assignment_;
    }
    clear_has_statement();
  }
}
inline ::vyper::Assignment* Statement::release_assignment() {
  // @@protoc_insertion_point(field_release:vyper.Statement.assignment)
  if (statement_case() == kAssignment) {
    clear_has_statement();
    ::vyper::Assignment* temp = _impl_.statement_.assignment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Assignment& Statement::_internal_assignment() const {
  return statement_case() == kAssignment
      ? *_impl_.statement_.assignment_
      : reinterpret_cast< ::vyper::Assignment&>(::vyper::_Assignment_default_instance_);
}
inline const ::vyper::Assignment& Statement::assignment() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.assignment)
  return _internal_assignment();
}
inline ::vyper::Assignment* Statement::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.assignment)
  if (statement_case() == kAssignment) {
    clear_has_statement();
    ::vyper::Assignment* temp = _impl_.statement_.assignment_;
    _impl_.statement_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_assignment(::vyper::Assignment* assignment) {
  clear_statement();
  if (assignment) {
    set_has_assignment();
    _impl_.statement_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.assignment)
}
inline ::vyper::Assignment* Statement::_internal_mutable_assignment() {
  if (statement_case() != kAssignment) {
    clear_statement();
    set_has_assignment();
    _impl_.statement_.assignment_ = CreateMaybeMessage< ::vyper::Assignment >(GetArenaForAllocation());
  }
  return _impl_.statement_.assignment_;
}
inline ::vyper::Assignment* Statement::mutable_assignment() {
  ::vyper::Assignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.assignment)
  return _msg;
}

// .vyper.IfStatement if_statement = 2;
inline bool Statement::has_if_statement() const {
  return statement_case() == kIfStatement;
}
inline bool Statement::_internal_has_if_statement() const {
  return statement_case() == kIfStatement;
}
inline void Statement::set_has_if_statement() {
  _impl_._oneof_case_[0] = kIfStatement;
}
inline void Statement::clear_if_statement() {
  if (statement_case() == kIfStatement) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.if_statement_;
    }
    clear_has_statement();
  }
}
inline ::vyper::IfStatement* Statement::release_if_statement() {
  // @@protoc_insertion_point(field_release:vyper.Statement.if_statement)
  if (statement_case() == kIfStatement) {
    clear_has_statement();
    ::vyper::IfStatement* temp = _impl_.statement_.if_statement_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.if_statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::IfStatement& Statement::_internal_if_statement() const {
  return statement_case() == kIfStatement
      ? *_impl_.statement_.if_statement_
      : reinterpret_cast< ::vyper::IfStatement&>(::vyper::_IfStatement_default_instance_);
}
inline const ::vyper::IfStatement& Statement::if_statement() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.if_statement)
  return _internal_if_statement();
}
inline ::vyper::IfStatement* Statement::unsafe_arena_release_if_statement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.if_statement)
  if (statement_case() == kIfStatement) {
    clear_has_statement();
    ::vyper::IfStatement* temp = _impl_.statement_.if_statement_;
    _impl_.statement_.if_statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_if_statement(::vyper::IfStatement* if_statement) {
  clear_statement();
  if (if_statement) {
    set_has_if_statement();
    _impl_.statement_.if_statement_ = if_statement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.if_statement)
}
inline ::vyper::IfStatement* Statement::_internal_mutable_if_statement() {
  if (statement_case() != kIfStatement) {
    clear_statement();
    set_has_if_statement();
    _impl_.statement_.if_statement_ = CreateMaybeMessage< ::vyper::IfStatement >(GetArenaForAllocation());
  }
  return _impl_.statement_.if_statement_;
}
inline ::vyper::IfStatement* Statement::mutable_if_statement() {
  ::vyper::IfStatement* _msg = _internal_mutable_if_statement();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.if_statement)
  return _msg;
}

// .vyper.FunctionCall function_call = 3;
inline bool Statement::has_function_call() const {
  return statement_case() == kFunctionCall;
}
inline bool Statement::_internal_has_function_call() const {
  return statement_case() == kFunctionCall;
}
inline void Statement::set_has_function_call() {
  _impl_._oneof_case_[0] = kFunctionCall;
}
inline void Statement::clear_function_call() {
  if (statement_case() == kFunctionCall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.function_call_;
    }
    clear_has_statement();
  }
}
inline ::vyper::FunctionCall* Statement::release_function_call() {
  // @@protoc_insertion_point(field_release:vyper.Statement.function_call)
  if (statement_case() == kFunctionCall) {
    clear_has_statement();
    ::vyper::FunctionCall* temp = _impl_.statement_.function_call_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::FunctionCall& Statement::_internal_function_call() const {
  return statement_case() == kFunctionCall
      ? *_impl_.statement_.function_call_
      : reinterpret_cast< ::vyper::FunctionCall&>(::vyper::_FunctionCall_default_instance_);
}
inline const ::vyper::FunctionCall& Statement::function_call() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.function_call)
  return _internal_function_call();
}
inline ::vyper::FunctionCall* Statement::unsafe_arena_release_function_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.function_call)
  if (statement_case() == kFunctionCall) {
    clear_has_statement();
    ::vyper::FunctionCall* temp = _impl_.statement_.function_call_;
    _impl_.statement_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_function_call(::vyper::FunctionCall* function_call) {
  clear_statement();
  if (function_call) {
    set_has_function_call();
    _impl_.statement_.function_call_ = function_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.function_call)
}
inline ::vyper::FunctionCall* Statement::_internal_mutable_function_call() {
  if (statement_case() != kFunctionCall) {
    clear_statement();
    set_has_function_call();
    _impl_.statement_.function_call_ = CreateMaybeMessage< ::vyper::FunctionCall >(GetArenaForAllocation());
  }
  return _impl_.statement_.function_call_;
}
inline ::vyper::FunctionCall* Statement::mutable_function_call() {
  ::vyper::FunctionCall* _msg = _internal_mutable_function_call();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.function_call)
  return _msg;
}

// .vyper.BuiltinCall builtin_call = 4;
inline bool Statement::has_builtin_call() const {
  return statement_case() == kBuiltinCall;
}
inline bool Statement::_internal_has_builtin_call() const {
  return statement_case() == kBuiltinCall;
}
inline void Statement::set_has_builtin_call() {
  _impl_._oneof_case_[0] = kBuiltinCall;
}
inline void Statement::clear_builtin_call() {
  if (statement_case() == kBuiltinCall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.builtin_call_;
    }
    clear_has_statement();
  }
}
inline ::vyper::BuiltinCall* Statement::release_builtin_call() {
  // @@protoc_insertion_point(field_release:vyper.Statement.builtin_call)
  if (statement_case() == kBuiltinCall) {
    clear_has_statement();
    ::vyper::BuiltinCall* temp = _impl_.statement_.builtin_call_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::BuiltinCall& Statement::_internal_builtin_call() const {
  return statement_case() == kBuiltinCall
      ? *_impl_.statement_.builtin_call_
      : reinterpret_cast< ::vyper::BuiltinCall&>(::vyper::_BuiltinCall_default_instance_);
}
inline const ::vyper::BuiltinCall& Statement::builtin_call() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.builtin_call)
  return _internal_builtin_call();
}
inline ::vyper::BuiltinCall* Statement::unsafe_arena_release_builtin_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.builtin_call)
  if (statement_case() == kBuiltinCall) {
    clear_has_statement();
    ::vyper::BuiltinCall* temp = _impl_.statement_.builtin_call_;
    _impl_.statement_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call) {
  clear_statement();
  if (builtin_call) {
    set_has_builtin_call();
    _impl_.statement_.builtin_call_ = builtin_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.builtin_call)
}
inline ::vyper::BuiltinCall* Statement::_internal_mutable_builtin_call() {
  if (statement_case() != kBuiltinCall) {
    clear_statement();
    set_has_builtin_call();
    _impl_.statement_.builtin_call_ = CreateMaybeMessage< ::vyper::BuiltinCall >(GetArenaForAllocation());
  }
  return _impl_.statement_.builtin_call_;
}
inline ::vyper::BuiltinCall* Statement::mutable_builtin_call() {
  ::vyper::BuiltinCall* _msg = _internal_mutable_builtin_call();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.builtin_call)
  return _msg;
}

// .vyper.VarDecl decl = 5;
inline bool Statement::has_decl() const {
  return statement_case() == kDecl;
}
inline bool Statement::_internal_has_decl() const {
  return statement_case() == kDecl;
}
inline void Statement::set_has_decl() {
  _impl_._oneof_case_[0] = kDecl;
}
inline void Statement::clear_decl() {
  if (statement_case() == kDecl) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.decl_;
    }
    clear_has_statement();
  }
}
inline ::vyper::VarDecl* Statement::release_decl() {
  // @@protoc_insertion_point(field_release:vyper.Statement.decl)
  if (statement_case() == kDecl) {
    clear_has_statement();
    ::vyper::VarDecl* temp = _impl_.statement_.decl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.decl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::VarDecl& Statement::_internal_decl() const {
  return statement_case() == kDecl
      ? *_impl_.statement_.decl_
      : reinterpret_cast< ::vyper::VarDecl&>(::vyper::_VarDecl_default_instance_);
}
inline const ::vyper::VarDecl& Statement::decl() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.decl)
  return _internal_decl();
}
inline ::vyper::VarDecl* Statement::unsafe_arena_release_decl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.decl)
  if (statement_case() == kDecl) {
    clear_has_statement();
    ::vyper::VarDecl* temp = _impl_.statement_.decl_;
    _impl_.statement_.decl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_decl(::vyper::VarDecl* decl) {
  clear_statement();
  if (decl) {
    set_has_decl();
    _impl_.statement_.decl_ = decl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.decl)
}
inline ::vyper::VarDecl* Statement::_internal_mutable_decl() {
  if (statement_case() != kDecl) {
    clear_statement();
    set_has_decl();
    _impl_.statement_.decl_ = CreateMaybeMessage< ::vyper::VarDecl >(GetArenaForAllocation());
  }
  return _impl_.statement_.decl_;
}
inline ::vyper::VarDecl* Statement::mutable_decl() {
  ::vyper::VarDecl* _msg = _internal_mutable_decl();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.decl)
  return _msg;
}

// .vyper.ValOrOp return = 6;
inline bool Statement::has_return_() const {
  return statement_case() == kReturn;
}
inline bool Statement::_internal_has_return_() const {
  return statement_case() == kReturn;
}
inline void Statement::set_has_return_() {
  _impl_._oneof_case_[0] = kReturn;
}
inline void Statement::clear_return_() {
  if (statement_case() == kReturn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.statement_.return__;
    }
    clear_has_statement();
  }
}
inline ::vyper::ValOrOp* Statement::release_return_() {
  // @@protoc_insertion_point(field_release:vyper.Statement.return)
  if (statement_case() == kReturn) {
    clear_has_statement();
    ::vyper::ValOrOp* temp = _impl_.statement_.return__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.statement_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::ValOrOp& Statement::_internal_return_() const {
  return statement_case() == kReturn
      ? *_impl_.statement_.return__
      : reinterpret_cast< ::vyper::ValOrOp&>(::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& Statement::return_() const {
  // @@protoc_insertion_point(field_get:vyper.Statement.return)
  return _internal_return_();
}
inline ::vyper::ValOrOp* Statement::unsafe_arena_release_return_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Statement.return)
  if (statement_case() == kReturn) {
    clear_has_statement();
    ::vyper::ValOrOp* temp = _impl_.statement_.return__;
    _impl_.statement_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_return_(::vyper::ValOrOp* return_) {
  clear_statement();
  if (return_) {
    set_has_return_();
    _impl_.statement_.return__ = return_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Statement.return)
}
inline ::vyper::ValOrOp* Statement::_internal_mutable_return_() {
  if (statement_case() != kReturn) {
    clear_statement();
    set_has_return_();
    _impl_.statement_.return__ = CreateMaybeMessage< ::vyper::ValOrOp >(GetArenaForAllocation());
  }
  return _impl_.statement_.return__;
}
inline ::vyper::ValOrOp* Statement::mutable_return_() {
  ::vyper::ValOrOp* _msg = _internal_mutable_return_();
  // @@protoc_insertion_point(field_mutable:vyper.Statement.return)
  return _msg;
}

inline bool Statement::has_statement() const {
  return statement_case() != STATEMENT_NOT_SET;
}
inline void Statement::clear_has_statement() {
  _impl_._oneof_case_[0] = STATEMENT_NOT_SET;
}
inline Statement::StatementCase Statement::statement_case() const {
  return Statement::StatementCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Uint256

// uint64 hb = 1;
inline void Uint256::clear_hb() {
  _impl_.hb_ = ::uint64_t{0u};
}
inline ::uint64_t Uint256::hb() const {
  // @@protoc_insertion_point(field_get:vyper.Uint256.hb)
  return _internal_hb();
}
inline void Uint256::set_hb(::uint64_t value) {
  _internal_set_hb(value);
  // @@protoc_insertion_point(field_set:vyper.Uint256.hb)
}
inline ::uint64_t Uint256::_internal_hb() const {
  return _impl_.hb_;
}
inline void Uint256::_internal_set_hb(::uint64_t value) {
  ;
  _impl_.hb_ = value;
}

// uint64 lb = 2;
inline void Uint256::clear_lb() {
  _impl_.lb_ = ::uint64_t{0u};
}
inline ::uint64_t Uint256::lb() const {
  // @@protoc_insertion_point(field_get:vyper.Uint256.lb)
  return _internal_lb();
}
inline void Uint256::set_lb(::uint64_t value) {
  _internal_set_lb(value);
  // @@protoc_insertion_point(field_set:vyper.Uint256.lb)
}
inline ::uint64_t Uint256::_internal_lb() const {
  return _impl_.lb_;
}
inline void Uint256::_internal_set_lb(::uint64_t value) {
  ;
  _impl_.lb_ = value;
}

// -------------------------------------------------------------------

// Value

// string str_literal = 1;
inline bool Value::has_str_literal() const {
  return value_case() == kStrLiteral;
}
inline void Value::set_has_str_literal() {
  _impl_._oneof_case_[0] = kStrLiteral;
}
inline void Value::clear_str_literal() {
  if (value_case() == kStrLiteral) {
    _impl_.value_.str_literal_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Value::str_literal() const {
  // @@protoc_insertion_point(field_get:vyper.Value.str_literal)
  return _internal_str_literal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Value::set_str_literal(Arg_&& arg,
                                                     Args_... args) {
  if (value_case() != kStrLiteral) {
    clear_value();

    set_has_str_literal();
    _impl_.value_.str_literal_.InitDefault();
  }
  _impl_.value_.str_literal_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.Value.str_literal)
}
inline std::string* Value::mutable_str_literal() {
  std::string* _s = _internal_mutable_str_literal();
  // @@protoc_insertion_point(field_mutable:vyper.Value.str_literal)
  return _s;
}
inline const std::string& Value::_internal_str_literal() const {
  if (value_case() != kStrLiteral) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.str_literal_.Get();
}
inline void Value::_internal_set_str_literal(const std::string& value) {
  if (value_case() != kStrLiteral) {
    clear_value();

    set_has_str_literal();
    _impl_.value_.str_literal_.InitDefault();
  }


  _impl_.value_.str_literal_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_str_literal() {
  if (value_case() != kStrLiteral) {
    clear_value();

    set_has_str_literal();
    _impl_.value_.str_literal_.InitDefault();
  }
  return _impl_.value_.str_literal_.Mutable( GetArenaForAllocation());
}
inline std::string* Value::release_str_literal() {
  // @@protoc_insertion_point(field_release:vyper.Value.str_literal)
  if (value_case() != kStrLiteral) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.str_literal_.Release();
}
inline void Value::set_allocated_str_literal(std::string* value) {
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_str_literal();
    _impl_.value_.str_literal_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Value.str_literal)
}

// string var_name = 2;
inline bool Value::has_var_name() const {
  return value_case() == kVarName;
}
inline void Value::set_has_var_name() {
  _impl_._oneof_case_[0] = kVarName;
}
inline void Value::clear_var_name() {
  if (value_case() == kVarName) {
    _impl_.value_.var_name_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Value::var_name() const {
  // @@protoc_insertion_point(field_get:vyper.Value.var_name)
  return _internal_var_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Value::set_var_name(Arg_&& arg,
                                                     Args_... args) {
  if (value_case() != kVarName) {
    clear_value();

    set_has_var_name();
    _impl_.value_.var_name_.InitDefault();
  }
  _impl_.value_.var_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.Value.var_name)
}
inline std::string* Value::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:vyper.Value.var_name)
  return _s;
}
inline const std::string& Value::_internal_var_name() const {
  if (value_case() != kVarName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.var_name_.Get();
}
inline void Value::_internal_set_var_name(const std::string& value) {
  if (value_case() != kVarName) {
    clear_value();

    set_has_var_name();
    _impl_.value_.var_name_.InitDefault();
  }


  _impl_.value_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_var_name() {
  if (value_case() != kVarName) {
    clear_value();

    set_has_var_name();
    _impl_.value_.var_name_.InitDefault();
  }
  return _impl_.value_.var_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Value::release_var_name() {
  // @@protoc_insertion_point(field_release:vyper.Value.var_name)
  if (value_case() != kVarName) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.var_name_.Release();
}
inline void Value::set_allocated_var_name(std::string* value) {
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_var_name();
    _impl_.value_.var_name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Value.var_name)
}

// .vyper.Uint256 num = 3;
inline bool Value::has_num() const {
  return value_case() == kNum;
}
inline bool Value::_internal_has_num() const {
  return value_case() == kNum;
}
inline void Value::set_has_num() {
  _impl_._oneof_case_[0] = kNum;
}
inline void Value::clear_num() {
  if (value_case() == kNum) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.num_;
    }
    clear_has_value();
  }
}
inline ::vyper::Uint256* Value::release_num() {
  // @@protoc_insertion_point(field_release:vyper.Value.num)
  if (value_case() == kNum) {
    clear_has_value();
    ::vyper::Uint256* temp = _impl_.value_.num_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.num_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Uint256& Value::_internal_num() const {
  return value_case() == kNum
      ? *_impl_.value_.num_
      : reinterpret_cast< ::vyper::Uint256&>(::vyper::_Uint256_default_instance_);
}
inline const ::vyper::Uint256& Value::num() const {
  // @@protoc_insertion_point(field_get:vyper.Value.num)
  return _internal_num();
}
inline ::vyper::Uint256* Value::unsafe_arena_release_num() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Value.num)
  if (value_case() == kNum) {
    clear_has_value();
    ::vyper::Uint256* temp = _impl_.value_.num_;
    _impl_.value_.num_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_num(::vyper::Uint256* num) {
  clear_value();
  if (num) {
    set_has_num();
    _impl_.value_.num_ = num;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Value.num)
}
inline ::vyper::Uint256* Value::_internal_mutable_num() {
  if (value_case() != kNum) {
    clear_value();
    set_has_num();
    _impl_.value_.num_ = CreateMaybeMessage< ::vyper::Uint256 >(GetArenaForAllocation());
  }
  return _impl_.value_.num_;
}
inline ::vyper::Uint256* Value::mutable_num() {
  ::vyper::Uint256* _msg = _internal_mutable_num();
  // @@protoc_insertion_point(field_mutable:vyper.Value.num)
  return _msg;
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Operator

// -------------------------------------------------------------------

// Operation

// .vyper.Value val1 = 1;
inline bool Operation::_internal_has_val1() const {
  return this != internal_default_instance() && _impl_.val1_ != nullptr;
}
inline bool Operation::has_val1() const {
  return _internal_has_val1();
}
inline void Operation::clear_val1() {
  if (GetArenaForAllocation() == nullptr && _impl_.val1_ != nullptr) {
    delete _impl_.val1_;
  }
  _impl_.val1_ = nullptr;
}
inline const ::vyper::Value& Operation::_internal_val1() const {
  const ::vyper::Value* p = _impl_.val1_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::Value&>(
      ::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& Operation::val1() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.val1)
  return _internal_val1();
}
inline void Operation::unsafe_arena_set_allocated_val1(
    ::vyper::Value* val1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.val1_);
  }
  _impl_.val1_ = val1;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.val1)
}
inline ::vyper::Value* Operation::release_val1() {
  
  ::vyper::Value* temp = _impl_.val1_;
  _impl_.val1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::Value* Operation::unsafe_arena_release_val1() {
  // @@protoc_insertion_point(field_release:vyper.Operation.val1)
  
  ::vyper::Value* temp = _impl_.val1_;
  _impl_.val1_ = nullptr;
  return temp;
}
inline ::vyper::Value* Operation::_internal_mutable_val1() {
  
  if (_impl_.val1_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Value>(GetArenaForAllocation());
    _impl_.val1_ = p;
  }
  return _impl_.val1_;
}
inline ::vyper::Value* Operation::mutable_val1() {
  ::vyper::Value* _msg = _internal_mutable_val1();
  // @@protoc_insertion_point(field_mutable:vyper.Operation.val1)
  return _msg;
}
inline void Operation::set_allocated_val1(::vyper::Value* val1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.val1_;
  }
  if (val1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(val1);
    if (message_arena != submessage_arena) {
      val1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val1, submessage_arena);
    }

  } else {

  }
  _impl_.val1_ = val1;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.val1)
}

// .vyper.Value val2 = 2;
inline bool Operation::_internal_has_val2() const {
  return this != internal_default_instance() && _impl_.val2_ != nullptr;
}
inline bool Operation::has_val2() const {
  return _internal_has_val2();
}
inline void Operation::clear_val2() {
  if (GetArenaForAllocation() == nullptr && _impl_.val2_ != nullptr) {
    delete _impl_.val2_;
  }
  _impl_.val2_ = nullptr;
}
inline const ::vyper::Value& Operation::_internal_val2() const {
  const ::vyper::Value* p = _impl_.val2_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::Value&>(
      ::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& Operation::val2() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.val2)
  return _internal_val2();
}
inline void Operation::unsafe_arena_set_allocated_val2(
    ::vyper::Value* val2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.val2_);
  }
  _impl_.val2_ = val2;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.val2)
}
inline ::vyper::Value* Operation::release_val2() {
  
  ::vyper::Value* temp = _impl_.val2_;
  _impl_.val2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::Value* Operation::unsafe_arena_release_val2() {
  // @@protoc_insertion_point(field_release:vyper.Operation.val2)
  
  ::vyper::Value* temp = _impl_.val2_;
  _impl_.val2_ = nullptr;
  return temp;
}
inline ::vyper::Value* Operation::_internal_mutable_val2() {
  
  if (_impl_.val2_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Value>(GetArenaForAllocation());
    _impl_.val2_ = p;
  }
  return _impl_.val2_;
}
inline ::vyper::Value* Operation::mutable_val2() {
  ::vyper::Value* _msg = _internal_mutable_val2();
  // @@protoc_insertion_point(field_mutable:vyper.Operation.val2)
  return _msg;
}
inline void Operation::set_allocated_val2(::vyper::Value* val2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.val2_;
  }
  if (val2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(val2);
    if (message_arena != submessage_arena) {
      val2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val2, submessage_arena);
    }

  } else {

  }
  _impl_.val2_ = val2;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.val2)
}

// .vyper.Operator operator = 3;
inline bool Operation::_internal_has_operator_() const {
  return this != internal_default_instance() && _impl_.operator__ != nullptr;
}
inline bool Operation::has_operator_() const {
  return _internal_has_operator_();
}
inline void Operation::clear_operator_() {
  if (GetArenaForAllocation() == nullptr && _impl_.operator__ != nullptr) {
    delete _impl_.operator__;
  }
  _impl_.operator__ = nullptr;
}
inline const ::vyper::Operator& Operation::_internal_operator_() const {
  const ::vyper::Operator* p = _impl_.operator__;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::Operator&>(
      ::vyper::_Operator_default_instance_);
}
inline const ::vyper::Operator& Operation::operator_() const {
  // @@protoc_insertion_point(field_get:vyper.Operation.operator)
  return _internal_operator_();
}
inline void Operation::unsafe_arena_set_allocated_operator_(
    ::vyper::Operator* operator_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operator__);
  }
  _impl_.operator__ = operator_;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Operation.operator)
}
inline ::vyper::Operator* Operation::release_operator_() {
  
  ::vyper::Operator* temp = _impl_.operator__;
  _impl_.operator__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::Operator* Operation::unsafe_arena_release_operator_() {
  // @@protoc_insertion_point(field_release:vyper.Operation.operator)
  
  ::vyper::Operator* temp = _impl_.operator__;
  _impl_.operator__ = nullptr;
  return temp;
}
inline ::vyper::Operator* Operation::_internal_mutable_operator_() {
  
  if (_impl_.operator__ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Operator>(GetArenaForAllocation());
    _impl_.operator__ = p;
  }
  return _impl_.operator__;
}
inline ::vyper::Operator* Operation::mutable_operator_() {
  ::vyper::Operator* _msg = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:vyper.Operation.operator)
  return _msg;
}
inline void Operation::set_allocated_operator_(::vyper::Operator* operator_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.operator__;
  }
  if (operator_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(operator_);
    if (message_arena != submessage_arena) {
      operator_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operator_, submessage_arena);
    }

  } else {

  }
  _impl_.operator__ = operator_;
  // @@protoc_insertion_point(field_set_allocated:vyper.Operation.operator)
}

// -------------------------------------------------------------------

// VarDecl

// string var_name = 1;
inline void VarDecl::clear_var_name() {
  _impl_.var_name_.ClearToEmpty();
}
inline const std::string& VarDecl::var_name() const {
  // @@protoc_insertion_point(field_get:vyper.VarDecl.var_name)
  return _internal_var_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VarDecl::set_var_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.var_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.VarDecl.var_name)
}
inline std::string* VarDecl::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:vyper.VarDecl.var_name)
  return _s;
}
inline const std::string& VarDecl::_internal_var_name() const {
  return _impl_.var_name_.Get();
}
inline void VarDecl::_internal_set_var_name(const std::string& value) {
  ;


  _impl_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VarDecl::_internal_mutable_var_name() {
  ;
  return _impl_.var_name_.Mutable( GetArenaForAllocation());
}
inline std::string* VarDecl::release_var_name() {
  // @@protoc_insertion_point(field_release:vyper.VarDecl.var_name)
  return _impl_.var_name_.Release();
}
inline void VarDecl::set_allocated_var_name(std::string* value) {
  _impl_.var_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.var_name_.IsDefault()) {
          _impl_.var_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vyper.VarDecl.var_name)
}

// .vyper.Type type = 2;
inline bool VarDecl::has_type() const {
  return _type_case() == kType;
}
inline bool VarDecl::_internal_has_type() const {
  return _type_case() == kType;
}
inline void VarDecl::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void VarDecl::clear_type() {
  if (_type_case() == kType) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_._type_.type_;
    }
    clear_has__type();
  }
}
inline ::vyper::Type* VarDecl::release_type() {
  // @@protoc_insertion_point(field_release:vyper.VarDecl.type)
  if (_type_case() == kType) {
    clear_has__type();
    ::vyper::Type* temp = _impl_._type_.type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_._type_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Type& VarDecl::_internal_type() const {
  return _type_case() == kType
      ? *_impl_._type_.type_
      : reinterpret_cast< ::vyper::Type&>(::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& VarDecl::type() const {
  // @@protoc_insertion_point(field_get:vyper.VarDecl.type)
  return _internal_type();
}
inline ::vyper::Type* VarDecl::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.VarDecl.type)
  if (_type_case() == kType) {
    clear_has__type();
    ::vyper::Type* temp = _impl_._type_.type_;
    _impl_._type_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VarDecl::unsafe_arena_set_allocated_type(::vyper::Type* type) {
  clear__type();
  if (type) {
    set_has_type();
    _impl_._type_.type_ = type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.VarDecl.type)
}
inline ::vyper::Type* VarDecl::_internal_mutable_type() {
  if (_type_case() != kType) {
    clear__type();
    set_has_type();
    _impl_._type_.type_ = CreateMaybeMessage< ::vyper::Type >(GetArenaForAllocation());
  }
  return _impl_._type_.type_;
}
inline ::vyper::Type* VarDecl::mutable_type() {
  ::vyper::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:vyper.VarDecl.type)
  return _msg;
}

// .vyper.SizedType stype = 3;
inline bool VarDecl::has_stype() const {
  return _type_case() == kStype;
}
inline bool VarDecl::_internal_has_stype() const {
  return _type_case() == kStype;
}
inline void VarDecl::set_has_stype() {
  _impl_._oneof_case_[0] = kStype;
}
inline void VarDecl::clear_stype() {
  if (_type_case() == kStype) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_._type_.stype_;
    }
    clear_has__type();
  }
}
inline ::vyper::SizedType* VarDecl::release_stype() {
  // @@protoc_insertion_point(field_release:vyper.VarDecl.stype)
  if (_type_case() == kStype) {
    clear_has__type();
    ::vyper::SizedType* temp = _impl_._type_.stype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_._type_.stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::SizedType& VarDecl::_internal_stype() const {
  return _type_case() == kStype
      ? *_impl_._type_.stype_
      : reinterpret_cast< ::vyper::SizedType&>(::vyper::_SizedType_default_instance_);
}
inline const ::vyper::SizedType& VarDecl::stype() const {
  // @@protoc_insertion_point(field_get:vyper.VarDecl.stype)
  return _internal_stype();
}
inline ::vyper::SizedType* VarDecl::unsafe_arena_release_stype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.VarDecl.stype)
  if (_type_case() == kStype) {
    clear_has__type();
    ::vyper::SizedType* temp = _impl_._type_.stype_;
    _impl_._type_.stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VarDecl::unsafe_arena_set_allocated_stype(::vyper::SizedType* stype) {
  clear__type();
  if (stype) {
    set_has_stype();
    _impl_._type_.stype_ = stype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.VarDecl.stype)
}
inline ::vyper::SizedType* VarDecl::_internal_mutable_stype() {
  if (_type_case() != kStype) {
    clear__type();
    set_has_stype();
    _impl_._type_.stype_ = CreateMaybeMessage< ::vyper::SizedType >(GetArenaForAllocation());
  }
  return _impl_._type_.stype_;
}
inline ::vyper::SizedType* VarDecl::mutable_stype() {
  ::vyper::SizedType* _msg = _internal_mutable_stype();
  // @@protoc_insertion_point(field_mutable:vyper.VarDecl.stype)
  return _msg;
}

// optional .vyper.ValOrOp val = 4;
inline bool VarDecl::has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.val_ != nullptr);
  return value;
}
inline void VarDecl::clear_val() {
  if (_impl_.val_ != nullptr) _impl_.val_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::vyper::ValOrOp& VarDecl::_internal_val() const {
  const ::vyper::ValOrOp* p = _impl_.val_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::ValOrOp&>(
      ::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& VarDecl::val() const {
  // @@protoc_insertion_point(field_get:vyper.VarDecl.val)
  return _internal_val();
}
inline void VarDecl::unsafe_arena_set_allocated_val(
    ::vyper::ValOrOp* val) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.val_);
  }
  _impl_.val_ = val;
  if (val) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.VarDecl.val)
}
inline ::vyper::ValOrOp* VarDecl::release_val() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::vyper::ValOrOp* temp = _impl_.val_;
  _impl_.val_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::ValOrOp* VarDecl::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_release:vyper.VarDecl.val)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::vyper::ValOrOp* temp = _impl_.val_;
  _impl_.val_ = nullptr;
  return temp;
}
inline ::vyper::ValOrOp* VarDecl::_internal_mutable_val() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.val_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::ValOrOp>(GetArenaForAllocation());
    _impl_.val_ = p;
  }
  return _impl_.val_;
}
inline ::vyper::ValOrOp* VarDecl::mutable_val() {
  ::vyper::ValOrOp* _msg = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:vyper.VarDecl.val)
  return _msg;
}
inline void VarDecl::set_allocated_val(::vyper::ValOrOp* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(val);
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.val_ = val;
  // @@protoc_insertion_point(field_set_allocated:vyper.VarDecl.val)
}

inline bool VarDecl::has__type() const {
  return _type_case() != _TYPE_NOT_SET;
}
inline void VarDecl::clear_has__type() {
  _impl_._oneof_case_[0] = _TYPE_NOT_SET;
}
inline VarDecl::TypeCase VarDecl::_type_case() const {
  return VarDecl::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValOrOp

// .vyper.Value val = 1;
inline bool ValOrOp::has_val() const {
  return value_or_op_case() == kVal;
}
inline bool ValOrOp::_internal_has_val() const {
  return value_or_op_case() == kVal;
}
inline void ValOrOp::set_has_val() {
  _impl_._oneof_case_[0] = kVal;
}
inline void ValOrOp::clear_val() {
  if (value_or_op_case() == kVal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_or_op_.val_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::Value* ValOrOp::release_val() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.val)
  if (value_or_op_case() == kVal) {
    clear_has_value_or_op();
    ::vyper::Value* temp = _impl_.value_or_op_.val_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_or_op_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Value& ValOrOp::_internal_val() const {
  return value_or_op_case() == kVal
      ? *_impl_.value_or_op_.val_
      : reinterpret_cast< ::vyper::Value&>(::vyper::_Value_default_instance_);
}
inline const ::vyper::Value& ValOrOp::val() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.val)
  return _internal_val();
}
inline ::vyper::Value* ValOrOp::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.val)
  if (value_or_op_case() == kVal) {
    clear_has_value_or_op();
    ::vyper::Value* temp = _impl_.value_or_op_.val_;
    _impl_.value_or_op_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_val(::vyper::Value* val) {
  clear_value_or_op();
  if (val) {
    set_has_val();
    _impl_.value_or_op_.val_ = val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.val)
}
inline ::vyper::Value* ValOrOp::_internal_mutable_val() {
  if (value_or_op_case() != kVal) {
    clear_value_or_op();
    set_has_val();
    _impl_.value_or_op_.val_ = CreateMaybeMessage< ::vyper::Value >(GetArenaForAllocation());
  }
  return _impl_.value_or_op_.val_;
}
inline ::vyper::Value* ValOrOp::mutable_val() {
  ::vyper::Value* _msg = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.val)
  return _msg;
}

// .vyper.Operation op = 2;
inline bool ValOrOp::has_op() const {
  return value_or_op_case() == kOp;
}
inline bool ValOrOp::_internal_has_op() const {
  return value_or_op_case() == kOp;
}
inline void ValOrOp::set_has_op() {
  _impl_._oneof_case_[0] = kOp;
}
inline void ValOrOp::clear_op() {
  if (value_or_op_case() == kOp) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_or_op_.op_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::Operation* ValOrOp::release_op() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.op)
  if (value_or_op_case() == kOp) {
    clear_has_value_or_op();
    ::vyper::Operation* temp = _impl_.value_or_op_.op_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_or_op_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Operation& ValOrOp::_internal_op() const {
  return value_or_op_case() == kOp
      ? *_impl_.value_or_op_.op_
      : reinterpret_cast< ::vyper::Operation&>(::vyper::_Operation_default_instance_);
}
inline const ::vyper::Operation& ValOrOp::op() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.op)
  return _internal_op();
}
inline ::vyper::Operation* ValOrOp::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.op)
  if (value_or_op_case() == kOp) {
    clear_has_value_or_op();
    ::vyper::Operation* temp = _impl_.value_or_op_.op_;
    _impl_.value_or_op_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_op(::vyper::Operation* op) {
  clear_value_or_op();
  if (op) {
    set_has_op();
    _impl_.value_or_op_.op_ = op;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.op)
}
inline ::vyper::Operation* ValOrOp::_internal_mutable_op() {
  if (value_or_op_case() != kOp) {
    clear_value_or_op();
    set_has_op();
    _impl_.value_or_op_.op_ = CreateMaybeMessage< ::vyper::Operation >(GetArenaForAllocation());
  }
  return _impl_.value_or_op_.op_;
}
inline ::vyper::Operation* ValOrOp::mutable_op() {
  ::vyper::Operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.op)
  return _msg;
}

// .vyper.FunctionCall func_call = 3;
inline bool ValOrOp::has_func_call() const {
  return value_or_op_case() == kFuncCall;
}
inline bool ValOrOp::_internal_has_func_call() const {
  return value_or_op_case() == kFuncCall;
}
inline void ValOrOp::set_has_func_call() {
  _impl_._oneof_case_[0] = kFuncCall;
}
inline void ValOrOp::clear_func_call() {
  if (value_or_op_case() == kFuncCall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_or_op_.func_call_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::FunctionCall* ValOrOp::release_func_call() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.func_call)
  if (value_or_op_case() == kFuncCall) {
    clear_has_value_or_op();
    ::vyper::FunctionCall* temp = _impl_.value_or_op_.func_call_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_or_op_.func_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::FunctionCall& ValOrOp::_internal_func_call() const {
  return value_or_op_case() == kFuncCall
      ? *_impl_.value_or_op_.func_call_
      : reinterpret_cast< ::vyper::FunctionCall&>(::vyper::_FunctionCall_default_instance_);
}
inline const ::vyper::FunctionCall& ValOrOp::func_call() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.func_call)
  return _internal_func_call();
}
inline ::vyper::FunctionCall* ValOrOp::unsafe_arena_release_func_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.func_call)
  if (value_or_op_case() == kFuncCall) {
    clear_has_value_or_op();
    ::vyper::FunctionCall* temp = _impl_.value_or_op_.func_call_;
    _impl_.value_or_op_.func_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_func_call(::vyper::FunctionCall* func_call) {
  clear_value_or_op();
  if (func_call) {
    set_has_func_call();
    _impl_.value_or_op_.func_call_ = func_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.func_call)
}
inline ::vyper::FunctionCall* ValOrOp::_internal_mutable_func_call() {
  if (value_or_op_case() != kFuncCall) {
    clear_value_or_op();
    set_has_func_call();
    _impl_.value_or_op_.func_call_ = CreateMaybeMessage< ::vyper::FunctionCall >(GetArenaForAllocation());
  }
  return _impl_.value_or_op_.func_call_;
}
inline ::vyper::FunctionCall* ValOrOp::mutable_func_call() {
  ::vyper::FunctionCall* _msg = _internal_mutable_func_call();
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.func_call)
  return _msg;
}

// .vyper.BuiltinCall builtin_call = 4;
inline bool ValOrOp::has_builtin_call() const {
  return value_or_op_case() == kBuiltinCall;
}
inline bool ValOrOp::_internal_has_builtin_call() const {
  return value_or_op_case() == kBuiltinCall;
}
inline void ValOrOp::set_has_builtin_call() {
  _impl_._oneof_case_[0] = kBuiltinCall;
}
inline void ValOrOp::clear_builtin_call() {
  if (value_or_op_case() == kBuiltinCall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_or_op_.builtin_call_;
    }
    clear_has_value_or_op();
  }
}
inline ::vyper::BuiltinCall* ValOrOp::release_builtin_call() {
  // @@protoc_insertion_point(field_release:vyper.ValOrOp.builtin_call)
  if (value_or_op_case() == kBuiltinCall) {
    clear_has_value_or_op();
    ::vyper::BuiltinCall* temp = _impl_.value_or_op_.builtin_call_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_or_op_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::BuiltinCall& ValOrOp::_internal_builtin_call() const {
  return value_or_op_case() == kBuiltinCall
      ? *_impl_.value_or_op_.builtin_call_
      : reinterpret_cast< ::vyper::BuiltinCall&>(::vyper::_BuiltinCall_default_instance_);
}
inline const ::vyper::BuiltinCall& ValOrOp::builtin_call() const {
  // @@protoc_insertion_point(field_get:vyper.ValOrOp.builtin_call)
  return _internal_builtin_call();
}
inline ::vyper::BuiltinCall* ValOrOp::unsafe_arena_release_builtin_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ValOrOp.builtin_call)
  if (value_or_op_case() == kBuiltinCall) {
    clear_has_value_or_op();
    ::vyper::BuiltinCall* temp = _impl_.value_or_op_.builtin_call_;
    _impl_.value_or_op_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValOrOp::unsafe_arena_set_allocated_builtin_call(::vyper::BuiltinCall* builtin_call) {
  clear_value_or_op();
  if (builtin_call) {
    set_has_builtin_call();
    _impl_.value_or_op_.builtin_call_ = builtin_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ValOrOp.builtin_call)
}
inline ::vyper::BuiltinCall* ValOrOp::_internal_mutable_builtin_call() {
  if (value_or_op_case() != kBuiltinCall) {
    clear_value_or_op();
    set_has_builtin_call();
    _impl_.value_or_op_.builtin_call_ = CreateMaybeMessage< ::vyper::BuiltinCall >(GetArenaForAllocation());
  }
  return _impl_.value_or_op_.builtin_call_;
}
inline ::vyper::BuiltinCall* ValOrOp::mutable_builtin_call() {
  ::vyper::BuiltinCall* _msg = _internal_mutable_builtin_call();
  // @@protoc_insertion_point(field_mutable:vyper.ValOrOp.builtin_call)
  return _msg;
}

inline bool ValOrOp::has_value_or_op() const {
  return value_or_op_case() != VALUE_OR_OP_NOT_SET;
}
inline void ValOrOp::clear_has_value_or_op() {
  _impl_._oneof_case_[0] = VALUE_OR_OP_NOT_SET;
}
inline ValOrOp::ValueOrOpCase ValOrOp::value_or_op_case() const {
  return ValOrOp::ValueOrOpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CodeBlock

// repeated .vyper.Statement statements = 1;
inline int CodeBlock::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int CodeBlock::statements_size() const {
  return _internal_statements_size();
}
inline void CodeBlock::clear_statements() {
  _impl_.statements_.Clear();
}
inline ::vyper::Statement* CodeBlock::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.CodeBlock.statements)
  return _impl_.statements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >*
CodeBlock::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:vyper.CodeBlock.statements)
  return &_impl_.statements_;
}
inline const ::vyper::Statement& CodeBlock::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const ::vyper::Statement& CodeBlock::statements(int index) const {
  // @@protoc_insertion_point(field_get:vyper.CodeBlock.statements)
  return _internal_statements(index);
}
inline ::vyper::Statement* CodeBlock::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline ::vyper::Statement* CodeBlock::add_statements() {
  ::vyper::Statement* _add = _internal_add_statements();
  // @@protoc_insertion_point(field_add:vyper.CodeBlock.statements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::Statement >&
CodeBlock::statements() const {
  // @@protoc_insertion_point(field_list:vyper.CodeBlock.statements)
  return _impl_.statements_;
}

// -------------------------------------------------------------------

// ArgDef

// string arg_name = 3;
inline void ArgDef::clear_arg_name() {
  _impl_.arg_name_.ClearToEmpty();
}
inline const std::string& ArgDef::arg_name() const {
  // @@protoc_insertion_point(field_get:vyper.ArgDef.arg_name)
  return _internal_arg_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArgDef::set_arg_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.arg_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.ArgDef.arg_name)
}
inline std::string* ArgDef::mutable_arg_name() {
  std::string* _s = _internal_mutable_arg_name();
  // @@protoc_insertion_point(field_mutable:vyper.ArgDef.arg_name)
  return _s;
}
inline const std::string& ArgDef::_internal_arg_name() const {
  return _impl_.arg_name_.Get();
}
inline void ArgDef::_internal_set_arg_name(const std::string& value) {
  ;


  _impl_.arg_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ArgDef::_internal_mutable_arg_name() {
  ;
  return _impl_.arg_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ArgDef::release_arg_name() {
  // @@protoc_insertion_point(field_release:vyper.ArgDef.arg_name)
  return _impl_.arg_name_.Release();
}
inline void ArgDef::set_allocated_arg_name(std::string* value) {
  _impl_.arg_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.arg_name_.IsDefault()) {
          _impl_.arg_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vyper.ArgDef.arg_name)
}

// .vyper.SizedType stype = 1;
inline bool ArgDef::has_stype() const {
  return arg_case() == kStype;
}
inline bool ArgDef::_internal_has_stype() const {
  return arg_case() == kStype;
}
inline void ArgDef::set_has_stype() {
  _impl_._oneof_case_[0] = kStype;
}
inline void ArgDef::clear_stype() {
  if (arg_case() == kStype) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.arg_.stype_;
    }
    clear_has_arg();
  }
}
inline ::vyper::SizedType* ArgDef::release_stype() {
  // @@protoc_insertion_point(field_release:vyper.ArgDef.stype)
  if (arg_case() == kStype) {
    clear_has_arg();
    ::vyper::SizedType* temp = _impl_.arg_.stype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_.stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::SizedType& ArgDef::_internal_stype() const {
  return arg_case() == kStype
      ? *_impl_.arg_.stype_
      : reinterpret_cast< ::vyper::SizedType&>(::vyper::_SizedType_default_instance_);
}
inline const ::vyper::SizedType& ArgDef::stype() const {
  // @@protoc_insertion_point(field_get:vyper.ArgDef.stype)
  return _internal_stype();
}
inline ::vyper::SizedType* ArgDef::unsafe_arena_release_stype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ArgDef.stype)
  if (arg_case() == kStype) {
    clear_has_arg();
    ::vyper::SizedType* temp = _impl_.arg_.stype_;
    _impl_.arg_.stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArgDef::unsafe_arena_set_allocated_stype(::vyper::SizedType* stype) {
  clear_arg();
  if (stype) {
    set_has_stype();
    _impl_.arg_.stype_ = stype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ArgDef.stype)
}
inline ::vyper::SizedType* ArgDef::_internal_mutable_stype() {
  if (arg_case() != kStype) {
    clear_arg();
    set_has_stype();
    _impl_.arg_.stype_ = CreateMaybeMessage< ::vyper::SizedType >(GetArenaForAllocation());
  }
  return _impl_.arg_.stype_;
}
inline ::vyper::SizedType* ArgDef::mutable_stype() {
  ::vyper::SizedType* _msg = _internal_mutable_stype();
  // @@protoc_insertion_point(field_mutable:vyper.ArgDef.stype)
  return _msg;
}

// .vyper.Type type = 2;
inline bool ArgDef::has_type() const {
  return arg_case() == kType;
}
inline bool ArgDef::_internal_has_type() const {
  return arg_case() == kType;
}
inline void ArgDef::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void ArgDef::clear_type() {
  if (arg_case() == kType) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.arg_.type_;
    }
    clear_has_arg();
  }
}
inline ::vyper::Type* ArgDef::release_type() {
  // @@protoc_insertion_point(field_release:vyper.ArgDef.type)
  if (arg_case() == kType) {
    clear_has_arg();
    ::vyper::Type* temp = _impl_.arg_.type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Type& ArgDef::_internal_type() const {
  return arg_case() == kType
      ? *_impl_.arg_.type_
      : reinterpret_cast< ::vyper::Type&>(::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& ArgDef::type() const {
  // @@protoc_insertion_point(field_get:vyper.ArgDef.type)
  return _internal_type();
}
inline ::vyper::Type* ArgDef::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.ArgDef.type)
  if (arg_case() == kType) {
    clear_has_arg();
    ::vyper::Type* temp = _impl_.arg_.type_;
    _impl_.arg_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArgDef::unsafe_arena_set_allocated_type(::vyper::Type* type) {
  clear_arg();
  if (type) {
    set_has_type();
    _impl_.arg_.type_ = type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ArgDef.type)
}
inline ::vyper::Type* ArgDef::_internal_mutable_type() {
  if (arg_case() != kType) {
    clear_arg();
    set_has_type();
    _impl_.arg_.type_ = CreateMaybeMessage< ::vyper::Type >(GetArenaForAllocation());
  }
  return _impl_.arg_.type_;
}
inline ::vyper::Type* ArgDef::mutable_type() {
  ::vyper::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:vyper.ArgDef.type)
  return _msg;
}

inline bool ArgDef::has_arg() const {
  return arg_case() != ARG_NOT_SET;
}
inline void ArgDef::clear_has_arg() {
  _impl_._oneof_case_[0] = ARG_NOT_SET;
}
inline ArgDef::ArgCase ArgDef::arg_case() const {
  return ArgDef::ArgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FunctionDef

// string function_name = 1;
inline void FunctionDef::clear_function_name() {
  _impl_.function_name_.ClearToEmpty();
}
inline const std::string& FunctionDef::function_name() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.function_name)
  return _internal_function_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FunctionDef::set_function_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.function_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.FunctionDef.function_name)
}
inline std::string* FunctionDef::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.function_name)
  return _s;
}
inline const std::string& FunctionDef::_internal_function_name() const {
  return _impl_.function_name_.Get();
}
inline void FunctionDef::_internal_set_function_name(const std::string& value) {
  ;


  _impl_.function_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionDef::_internal_mutable_function_name() {
  ;
  return _impl_.function_name_.Mutable( GetArenaForAllocation());
}
inline std::string* FunctionDef::release_function_name() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.function_name)
  return _impl_.function_name_.Release();
}
inline void FunctionDef::set_allocated_function_name(std::string* value) {
  _impl_.function_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.function_name_.IsDefault()) {
          _impl_.function_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.function_name)
}

// repeated .vyper.ArgDef args = 2;
inline int FunctionDef::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int FunctionDef::args_size() const {
  return _internal_args_size();
}
inline void FunctionDef::clear_args() {
  _impl_.args_.Clear();
}
inline ::vyper::ArgDef* FunctionDef::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >*
FunctionDef::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.FunctionDef.args)
  return &_impl_.args_;
}
inline const ::vyper::ArgDef& FunctionDef::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::vyper::ArgDef& FunctionDef::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.args)
  return _internal_args(index);
}
inline ::vyper::ArgDef* FunctionDef::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::vyper::ArgDef* FunctionDef::add_args() {
  ::vyper::ArgDef* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:vyper.FunctionDef.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ArgDef >&
FunctionDef::args() const {
  // @@protoc_insertion_point(field_list:vyper.FunctionDef.args)
  return _impl_.args_;
}

// .vyper.CodeBlock block = 3;
inline bool FunctionDef::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool FunctionDef::has_block() const {
  return _internal_has_block();
}
inline void FunctionDef::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
inline const ::vyper::CodeBlock& FunctionDef::_internal_block() const {
  const ::vyper::CodeBlock* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::CodeBlock&>(
      ::vyper::_CodeBlock_default_instance_);
}
inline const ::vyper::CodeBlock& FunctionDef::block() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.block)
  return _internal_block();
}
inline void FunctionDef::unsafe_arena_set_allocated_block(
    ::vyper::CodeBlock* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.block)
}
inline ::vyper::CodeBlock* FunctionDef::release_block() {
  
  ::vyper::CodeBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::CodeBlock* FunctionDef::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.block)
  
  ::vyper::CodeBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::vyper::CodeBlock* FunctionDef::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::CodeBlock>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::vyper::CodeBlock* FunctionDef::mutable_block() {
  ::vyper::CodeBlock* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.block)
  return _msg;
}
inline void FunctionDef::set_allocated_block(::vyper::CodeBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }

  } else {

  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionDef.block)
}

// bool external = 4;
inline void FunctionDef::clear_external() {
  _impl_.external_ = false;
}
inline bool FunctionDef::external() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.external)
  return _internal_external();
}
inline void FunctionDef::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:vyper.FunctionDef.external)
}
inline bool FunctionDef::_internal_external() const {
  return _impl_.external_;
}
inline void FunctionDef::_internal_set_external(bool value) {
  ;
  _impl_.external_ = value;
}

// .vyper.Type return_type = 5;
inline bool FunctionDef::has_return_type() const {
  return ret_type_case() == kReturnType;
}
inline bool FunctionDef::_internal_has_return_type() const {
  return ret_type_case() == kReturnType;
}
inline void FunctionDef::set_has_return_type() {
  _impl_._oneof_case_[0] = kReturnType;
}
inline void FunctionDef::clear_return_type() {
  if (ret_type_case() == kReturnType) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ret_type_.return_type_;
    }
    clear_has_ret_type();
  }
}
inline ::vyper::Type* FunctionDef::release_return_type() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.return_type)
  if (ret_type_case() == kReturnType) {
    clear_has_ret_type();
    ::vyper::Type* temp = _impl_.ret_type_.return_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ret_type_.return_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::Type& FunctionDef::_internal_return_type() const {
  return ret_type_case() == kReturnType
      ? *_impl_.ret_type_.return_type_
      : reinterpret_cast< ::vyper::Type&>(::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& FunctionDef::return_type() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.return_type)
  return _internal_return_type();
}
inline ::vyper::Type* FunctionDef::unsafe_arena_release_return_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.FunctionDef.return_type)
  if (ret_type_case() == kReturnType) {
    clear_has_ret_type();
    ::vyper::Type* temp = _impl_.ret_type_.return_type_;
    _impl_.ret_type_.return_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionDef::unsafe_arena_set_allocated_return_type(::vyper::Type* return_type) {
  clear_ret_type();
  if (return_type) {
    set_has_return_type();
    _impl_.ret_type_.return_type_ = return_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.return_type)
}
inline ::vyper::Type* FunctionDef::_internal_mutable_return_type() {
  if (ret_type_case() != kReturnType) {
    clear_ret_type();
    set_has_return_type();
    _impl_.ret_type_.return_type_ = CreateMaybeMessage< ::vyper::Type >(GetArenaForAllocation());
  }
  return _impl_.ret_type_.return_type_;
}
inline ::vyper::Type* FunctionDef::mutable_return_type() {
  ::vyper::Type* _msg = _internal_mutable_return_type();
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.return_type)
  return _msg;
}

// .vyper.SizedType return_stype = 6;
inline bool FunctionDef::has_return_stype() const {
  return ret_type_case() == kReturnStype;
}
inline bool FunctionDef::_internal_has_return_stype() const {
  return ret_type_case() == kReturnStype;
}
inline void FunctionDef::set_has_return_stype() {
  _impl_._oneof_case_[0] = kReturnStype;
}
inline void FunctionDef::clear_return_stype() {
  if (ret_type_case() == kReturnStype) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ret_type_.return_stype_;
    }
    clear_has_ret_type();
  }
}
inline ::vyper::SizedType* FunctionDef::release_return_stype() {
  // @@protoc_insertion_point(field_release:vyper.FunctionDef.return_stype)
  if (ret_type_case() == kReturnStype) {
    clear_has_ret_type();
    ::vyper::SizedType* temp = _impl_.ret_type_.return_stype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ret_type_.return_stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::SizedType& FunctionDef::_internal_return_stype() const {
  return ret_type_case() == kReturnStype
      ? *_impl_.ret_type_.return_stype_
      : reinterpret_cast< ::vyper::SizedType&>(::vyper::_SizedType_default_instance_);
}
inline const ::vyper::SizedType& FunctionDef::return_stype() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionDef.return_stype)
  return _internal_return_stype();
}
inline ::vyper::SizedType* FunctionDef::unsafe_arena_release_return_stype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.FunctionDef.return_stype)
  if (ret_type_case() == kReturnStype) {
    clear_has_ret_type();
    ::vyper::SizedType* temp = _impl_.ret_type_.return_stype_;
    _impl_.ret_type_.return_stype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionDef::unsafe_arena_set_allocated_return_stype(::vyper::SizedType* return_stype) {
  clear_ret_type();
  if (return_stype) {
    set_has_return_stype();
    _impl_.ret_type_.return_stype_ = return_stype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.FunctionDef.return_stype)
}
inline ::vyper::SizedType* FunctionDef::_internal_mutable_return_stype() {
  if (ret_type_case() != kReturnStype) {
    clear_ret_type();
    set_has_return_stype();
    _impl_.ret_type_.return_stype_ = CreateMaybeMessage< ::vyper::SizedType >(GetArenaForAllocation());
  }
  return _impl_.ret_type_.return_stype_;
}
inline ::vyper::SizedType* FunctionDef::mutable_return_stype() {
  ::vyper::SizedType* _msg = _internal_mutable_return_stype();
  // @@protoc_insertion_point(field_mutable:vyper.FunctionDef.return_stype)
  return _msg;
}

inline bool FunctionDef::has_ret_type() const {
  return ret_type_case() != RET_TYPE_NOT_SET;
}
inline void FunctionDef::clear_has_ret_type() {
  _impl_._oneof_case_[0] = RET_TYPE_NOT_SET;
}
inline FunctionDef::RetTypeCase FunctionDef::ret_type_case() const {
  return FunctionDef::RetTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Type

// .vyper.TYPE_ENUM typeVal = 1;
inline void Type::clear_typeval() {
  _impl_.typeval_ = 0;
}
inline ::vyper::TYPE_ENUM Type::typeval() const {
  // @@protoc_insertion_point(field_get:vyper.Type.typeVal)
  return _internal_typeval();
}
inline void Type::set_typeval(::vyper::TYPE_ENUM value) {
   _internal_set_typeval(value);
  // @@protoc_insertion_point(field_set:vyper.Type.typeVal)
}
inline ::vyper::TYPE_ENUM Type::_internal_typeval() const {
  return static_cast<::vyper::TYPE_ENUM>(_impl_.typeval_);
}
inline void Type::_internal_set_typeval(::vyper::TYPE_ENUM value) {
  ;
  _impl_.typeval_ = value;
}

// -------------------------------------------------------------------

// SizedType

// .vyper.SIZED_TYPE_ENUM typeVal = 1;
inline void SizedType::clear_typeval() {
  _impl_.typeval_ = 0;
}
inline ::vyper::SIZED_TYPE_ENUM SizedType::typeval() const {
  // @@protoc_insertion_point(field_get:vyper.SizedType.typeVal)
  return _internal_typeval();
}
inline void SizedType::set_typeval(::vyper::SIZED_TYPE_ENUM value) {
   _internal_set_typeval(value);
  // @@protoc_insertion_point(field_set:vyper.SizedType.typeVal)
}
inline ::vyper::SIZED_TYPE_ENUM SizedType::_internal_typeval() const {
  return static_cast<::vyper::SIZED_TYPE_ENUM>(_impl_.typeval_);
}
inline void SizedType::_internal_set_typeval(::vyper::SIZED_TYPE_ENUM value) {
  ;
  _impl_.typeval_ = value;
}

// uint32 size = 2;
inline void SizedType::clear_size() {
  _impl_.size_ = 0u;
}
inline ::uint32_t SizedType::size() const {
  // @@protoc_insertion_point(field_get:vyper.SizedType.size)
  return _internal_size();
}
inline void SizedType::set_size(::uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:vyper.SizedType.size)
}
inline ::uint32_t SizedType::_internal_size() const {
  return _impl_.size_;
}
inline void SizedType::_internal_set_size(::uint32_t value) {
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// Assignment

// string variable_name = 1;
inline bool Assignment::has_variable_name() const {
  return var_case() == kVariableName;
}
inline void Assignment::set_has_variable_name() {
  _impl_._oneof_case_[0] = kVariableName;
}
inline void Assignment::clear_variable_name() {
  if (var_case() == kVariableName) {
    _impl_.var_.variable_name_.Destroy();
    clear_has_var();
  }
}
inline const std::string& Assignment::variable_name() const {
  // @@protoc_insertion_point(field_get:vyper.Assignment.variable_name)
  return _internal_variable_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Assignment::set_variable_name(Arg_&& arg,
                                                     Args_... args) {
  if (var_case() != kVariableName) {
    clear_var();

    set_has_variable_name();
    _impl_.var_.variable_name_.InitDefault();
  }
  _impl_.var_.variable_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.Assignment.variable_name)
}
inline std::string* Assignment::mutable_variable_name() {
  std::string* _s = _internal_mutable_variable_name();
  // @@protoc_insertion_point(field_mutable:vyper.Assignment.variable_name)
  return _s;
}
inline const std::string& Assignment::_internal_variable_name() const {
  if (var_case() != kVariableName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.var_.variable_name_.Get();
}
inline void Assignment::_internal_set_variable_name(const std::string& value) {
  if (var_case() != kVariableName) {
    clear_var();

    set_has_variable_name();
    _impl_.var_.variable_name_.InitDefault();
  }


  _impl_.var_.variable_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Assignment::_internal_mutable_variable_name() {
  if (var_case() != kVariableName) {
    clear_var();

    set_has_variable_name();
    _impl_.var_.variable_name_.InitDefault();
  }
  return _impl_.var_.variable_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Assignment::release_variable_name() {
  // @@protoc_insertion_point(field_release:vyper.Assignment.variable_name)
  if (var_case() != kVariableName) {
    return nullptr;
  }
  clear_has_var();
  return _impl_.var_.variable_name_.Release();
}
inline void Assignment::set_allocated_variable_name(std::string* value) {
  if (has_var()) {
    clear_var();
  }
  if (value != nullptr) {
    set_has_variable_name();
    _impl_.var_.variable_name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vyper.Assignment.variable_name)
}

// .vyper.VarDecl decl = 2;
inline bool Assignment::has_decl() const {
  return var_case() == kDecl;
}
inline bool Assignment::_internal_has_decl() const {
  return var_case() == kDecl;
}
inline void Assignment::set_has_decl() {
  _impl_._oneof_case_[0] = kDecl;
}
inline void Assignment::clear_decl() {
  if (var_case() == kDecl) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.var_.decl_;
    }
    clear_has_var();
  }
}
inline ::vyper::VarDecl* Assignment::release_decl() {
  // @@protoc_insertion_point(field_release:vyper.Assignment.decl)
  if (var_case() == kDecl) {
    clear_has_var();
    ::vyper::VarDecl* temp = _impl_.var_.decl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.var_.decl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::VarDecl& Assignment::_internal_decl() const {
  return var_case() == kDecl
      ? *_impl_.var_.decl_
      : reinterpret_cast< ::vyper::VarDecl&>(::vyper::_VarDecl_default_instance_);
}
inline const ::vyper::VarDecl& Assignment::decl() const {
  // @@protoc_insertion_point(field_get:vyper.Assignment.decl)
  return _internal_decl();
}
inline ::vyper::VarDecl* Assignment::unsafe_arena_release_decl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.Assignment.decl)
  if (var_case() == kDecl) {
    clear_has_var();
    ::vyper::VarDecl* temp = _impl_.var_.decl_;
    _impl_.var_.decl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Assignment::unsafe_arena_set_allocated_decl(::vyper::VarDecl* decl) {
  clear_var();
  if (decl) {
    set_has_decl();
    _impl_.var_.decl_ = decl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Assignment.decl)
}
inline ::vyper::VarDecl* Assignment::_internal_mutable_decl() {
  if (var_case() != kDecl) {
    clear_var();
    set_has_decl();
    _impl_.var_.decl_ = CreateMaybeMessage< ::vyper::VarDecl >(GetArenaForAllocation());
  }
  return _impl_.var_.decl_;
}
inline ::vyper::VarDecl* Assignment::mutable_decl() {
  ::vyper::VarDecl* _msg = _internal_mutable_decl();
  // @@protoc_insertion_point(field_mutable:vyper.Assignment.decl)
  return _msg;
}

// .vyper.ValOrOp value = 3;
inline bool Assignment::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Assignment::has_value() const {
  return _internal_has_value();
}
inline void Assignment::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::vyper::ValOrOp& Assignment::_internal_value() const {
  const ::vyper::ValOrOp* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::ValOrOp&>(
      ::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& Assignment::value() const {
  // @@protoc_insertion_point(field_get:vyper.Assignment.value)
  return _internal_value();
}
inline void Assignment::unsafe_arena_set_allocated_value(
    ::vyper::ValOrOp* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.Assignment.value)
}
inline ::vyper::ValOrOp* Assignment::release_value() {
  
  ::vyper::ValOrOp* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::ValOrOp* Assignment::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:vyper.Assignment.value)
  
  ::vyper::ValOrOp* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::vyper::ValOrOp* Assignment::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::ValOrOp>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::vyper::ValOrOp* Assignment::mutable_value() {
  ::vyper::ValOrOp* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:vyper.Assignment.value)
  return _msg;
}
inline void Assignment::set_allocated_value(::vyper::ValOrOp* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }

  } else {

  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:vyper.Assignment.value)
}

inline bool Assignment::has_var() const {
  return var_case() != VAR_NOT_SET;
}
inline void Assignment::clear_has_var() {
  _impl_._oneof_case_[0] = VAR_NOT_SET;
}
inline Assignment::VarCase Assignment::var_case() const {
  return Assignment::VarCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IfStatement

// string condition = 1;
inline void IfStatement::clear_condition() {
  _impl_.condition_.ClearToEmpty();
}
inline const std::string& IfStatement::condition() const {
  // @@protoc_insertion_point(field_get:vyper.IfStatement.condition)
  return _internal_condition();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IfStatement::set_condition(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.condition_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.IfStatement.condition)
}
inline std::string* IfStatement::mutable_condition() {
  std::string* _s = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:vyper.IfStatement.condition)
  return _s;
}
inline const std::string& IfStatement::_internal_condition() const {
  return _impl_.condition_.Get();
}
inline void IfStatement::_internal_set_condition(const std::string& value) {
  ;


  _impl_.condition_.Set(value, GetArenaForAllocation());
}
inline std::string* IfStatement::_internal_mutable_condition() {
  ;
  return _impl_.condition_.Mutable( GetArenaForAllocation());
}
inline std::string* IfStatement::release_condition() {
  // @@protoc_insertion_point(field_release:vyper.IfStatement.condition)
  return _impl_.condition_.Release();
}
inline void IfStatement::set_allocated_condition(std::string* value) {
  _impl_.condition_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.condition_.IsDefault()) {
          _impl_.condition_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vyper.IfStatement.condition)
}

// .vyper.CodeBlock block = 2;
inline bool IfStatement::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool IfStatement::has_block() const {
  return _internal_has_block();
}
inline void IfStatement::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
inline const ::vyper::CodeBlock& IfStatement::_internal_block() const {
  const ::vyper::CodeBlock* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::CodeBlock&>(
      ::vyper::_CodeBlock_default_instance_);
}
inline const ::vyper::CodeBlock& IfStatement::block() const {
  // @@protoc_insertion_point(field_get:vyper.IfStatement.block)
  return _internal_block();
}
inline void IfStatement::unsafe_arena_set_allocated_block(
    ::vyper::CodeBlock* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.IfStatement.block)
}
inline ::vyper::CodeBlock* IfStatement::release_block() {
  
  ::vyper::CodeBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::CodeBlock* IfStatement::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:vyper.IfStatement.block)
  
  ::vyper::CodeBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::vyper::CodeBlock* IfStatement::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::CodeBlock>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::vyper::CodeBlock* IfStatement::mutable_block() {
  ::vyper::CodeBlock* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:vyper.IfStatement.block)
  return _msg;
}
inline void IfStatement::set_allocated_block(::vyper::CodeBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }

  } else {

  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:vyper.IfStatement.block)
}

// -------------------------------------------------------------------

// FunctionCall

// string function_name = 1;
inline void FunctionCall::clear_function_name() {
  _impl_.function_name_.ClearToEmpty();
}
inline const std::string& FunctionCall::function_name() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionCall.function_name)
  return _internal_function_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FunctionCall::set_function_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.function_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vyper.FunctionCall.function_name)
}
inline std::string* FunctionCall::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:vyper.FunctionCall.function_name)
  return _s;
}
inline const std::string& FunctionCall::_internal_function_name() const {
  return _impl_.function_name_.Get();
}
inline void FunctionCall::_internal_set_function_name(const std::string& value) {
  ;


  _impl_.function_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionCall::_internal_mutable_function_name() {
  ;
  return _impl_.function_name_.Mutable( GetArenaForAllocation());
}
inline std::string* FunctionCall::release_function_name() {
  // @@protoc_insertion_point(field_release:vyper.FunctionCall.function_name)
  return _impl_.function_name_.Release();
}
inline void FunctionCall::set_allocated_function_name(std::string* value) {
  _impl_.function_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.function_name_.IsDefault()) {
          _impl_.function_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vyper.FunctionCall.function_name)
}

// repeated .vyper.ValOrOp args = 2;
inline int FunctionCall::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int FunctionCall::args_size() const {
  return _internal_args_size();
}
inline void FunctionCall::clear_args() {
  _impl_.args_.Clear();
}
inline ::vyper::ValOrOp* FunctionCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.FunctionCall.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >*
FunctionCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.FunctionCall.args)
  return &_impl_.args_;
}
inline const ::vyper::ValOrOp& FunctionCall::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::vyper::ValOrOp& FunctionCall::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.FunctionCall.args)
  return _internal_args(index);
}
inline ::vyper::ValOrOp* FunctionCall::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::vyper::ValOrOp* FunctionCall::add_args() {
  ::vyper::ValOrOp* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:vyper.FunctionCall.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::ValOrOp >&
FunctionCall::args() const {
  // @@protoc_insertion_point(field_list:vyper.FunctionCall.args)
  return _impl_.args_;
}

// bool external = 3;
inline void FunctionCall::clear_external() {
  _impl_.external_ = false;
}
inline bool FunctionCall::external() const {
  // @@protoc_insertion_point(field_get:vyper.FunctionCall.external)
  return _internal_external();
}
inline void FunctionCall::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:vyper.FunctionCall.external)
}
inline bool FunctionCall::_internal_external() const {
  return _impl_.external_;
}
inline void FunctionCall::_internal_set_external(bool value) {
  ;
  _impl_.external_ = value;
}

// -------------------------------------------------------------------

// ConcatCall

// repeated string args = 1;
inline int ConcatCall::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ConcatCall::args_size() const {
  return _internal_args_size();
}
inline void ConcatCall::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* ConcatCall::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:vyper.ConcatCall.args)
  return _s;
}
inline const std::string& ConcatCall::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& ConcatCall::args(int index) const {
  // @@protoc_insertion_point(field_get:vyper.ConcatCall.args)
  return _internal_args(index);
}
inline std::string* ConcatCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.ConcatCall.args)
  return _impl_.args_.Mutable(index);
}
inline void ConcatCall::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vyper.ConcatCall.args)
}
inline void ConcatCall::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vyper.ConcatCall.args)
}
inline void ConcatCall::set_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vyper.ConcatCall.args)
}
inline void ConcatCall::set_args(int index, const char* value,
                              std::size_t size) {
  _impl_.args_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vyper.ConcatCall.args)
}
inline void ConcatCall::set_args(int index, absl::string_view value) {
  _impl_.args_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:vyper.ConcatCall.args)
}
inline std::string* ConcatCall::_internal_add_args() { return _impl_.args_.Add(); }
inline void ConcatCall::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(const char* value, std::size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vyper.ConcatCall.args)
}
inline void ConcatCall::add_args(absl::string_view value) {
  _impl_.args_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:vyper.ConcatCall.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConcatCall::args() const {
  // @@protoc_insertion_point(field_list:vyper.ConcatCall.args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ConcatCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vyper.ConcatCall.args)
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// ConvertCall

// .vyper.ValOrOp value = 1;
inline bool ConvertCall::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool ConvertCall::has_value() const {
  return _internal_has_value();
}
inline void ConvertCall::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::vyper::ValOrOp& ConvertCall::_internal_value() const {
  const ::vyper::ValOrOp* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::ValOrOp&>(
      ::vyper::_ValOrOp_default_instance_);
}
inline const ::vyper::ValOrOp& ConvertCall::value() const {
  // @@protoc_insertion_point(field_get:vyper.ConvertCall.value)
  return _internal_value();
}
inline void ConvertCall::unsafe_arena_set_allocated_value(
    ::vyper::ValOrOp* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ConvertCall.value)
}
inline ::vyper::ValOrOp* ConvertCall::release_value() {
  
  ::vyper::ValOrOp* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::ValOrOp* ConvertCall::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:vyper.ConvertCall.value)
  
  ::vyper::ValOrOp* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::vyper::ValOrOp* ConvertCall::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::ValOrOp>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::vyper::ValOrOp* ConvertCall::mutable_value() {
  ::vyper::ValOrOp* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:vyper.ConvertCall.value)
  return _msg;
}
inline void ConvertCall::set_allocated_value(::vyper::ValOrOp* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }

  } else {

  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:vyper.ConvertCall.value)
}

// .vyper.Type type = 2;
inline bool ConvertCall::_internal_has_type() const {
  return this != internal_default_instance() && _impl_.type_ != nullptr;
}
inline bool ConvertCall::has_type() const {
  return _internal_has_type();
}
inline void ConvertCall::clear_type() {
  if (GetArenaForAllocation() == nullptr && _impl_.type_ != nullptr) {
    delete _impl_.type_;
  }
  _impl_.type_ = nullptr;
}
inline const ::vyper::Type& ConvertCall::_internal_type() const {
  const ::vyper::Type* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::vyper::Type&>(
      ::vyper::_Type_default_instance_);
}
inline const ::vyper::Type& ConvertCall::type() const {
  // @@protoc_insertion_point(field_get:vyper.ConvertCall.type)
  return _internal_type();
}
inline void ConvertCall::unsafe_arena_set_allocated_type(
    ::vyper::Type* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = type;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.ConvertCall.type)
}
inline ::vyper::Type* ConvertCall::release_type() {
  
  ::vyper::Type* temp = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vyper::Type* ConvertCall::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:vyper.ConvertCall.type)
  
  ::vyper::Type* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::vyper::Type* ConvertCall::_internal_mutable_type() {
  
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::vyper::Type>(GetArenaForAllocation());
    _impl_.type_ = p;
  }
  return _impl_.type_;
}
inline ::vyper::Type* ConvertCall::mutable_type() {
  ::vyper::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:vyper.ConvertCall.type)
  return _msg;
}
inline void ConvertCall::set_allocated_type(::vyper::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }

  } else {

  }
  _impl_.type_ = type;
  // @@protoc_insertion_point(field_set_allocated:vyper.ConvertCall.type)
}

// -------------------------------------------------------------------

// BuiltinCall

// .vyper.ConcatCall concat = 1;
inline bool BuiltinCall::has_concat() const {
  return call_case() == kConcat;
}
inline bool BuiltinCall::_internal_has_concat() const {
  return call_case() == kConcat;
}
inline void BuiltinCall::set_has_concat() {
  _impl_._oneof_case_[0] = kConcat;
}
inline void BuiltinCall::clear_concat() {
  if (call_case() == kConcat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.call_.concat_;
    }
    clear_has_call();
  }
}
inline ::vyper::ConcatCall* BuiltinCall::release_concat() {
  // @@protoc_insertion_point(field_release:vyper.BuiltinCall.concat)
  if (call_case() == kConcat) {
    clear_has_call();
    ::vyper::ConcatCall* temp = _impl_.call_.concat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.call_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::ConcatCall& BuiltinCall::_internal_concat() const {
  return call_case() == kConcat
      ? *_impl_.call_.concat_
      : reinterpret_cast< ::vyper::ConcatCall&>(::vyper::_ConcatCall_default_instance_);
}
inline const ::vyper::ConcatCall& BuiltinCall::concat() const {
  // @@protoc_insertion_point(field_get:vyper.BuiltinCall.concat)
  return _internal_concat();
}
inline ::vyper::ConcatCall* BuiltinCall::unsafe_arena_release_concat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.BuiltinCall.concat)
  if (call_case() == kConcat) {
    clear_has_call();
    ::vyper::ConcatCall* temp = _impl_.call_.concat_;
    _impl_.call_.concat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinCall::unsafe_arena_set_allocated_concat(::vyper::ConcatCall* concat) {
  clear_call();
  if (concat) {
    set_has_concat();
    _impl_.call_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.BuiltinCall.concat)
}
inline ::vyper::ConcatCall* BuiltinCall::_internal_mutable_concat() {
  if (call_case() != kConcat) {
    clear_call();
    set_has_concat();
    _impl_.call_.concat_ = CreateMaybeMessage< ::vyper::ConcatCall >(GetArenaForAllocation());
  }
  return _impl_.call_.concat_;
}
inline ::vyper::ConcatCall* BuiltinCall::mutable_concat() {
  ::vyper::ConcatCall* _msg = _internal_mutable_concat();
  // @@protoc_insertion_point(field_mutable:vyper.BuiltinCall.concat)
  return _msg;
}

// .vyper.ConvertCall convert = 2;
inline bool BuiltinCall::has_convert() const {
  return call_case() == kConvert;
}
inline bool BuiltinCall::_internal_has_convert() const {
  return call_case() == kConvert;
}
inline void BuiltinCall::set_has_convert() {
  _impl_._oneof_case_[0] = kConvert;
}
inline void BuiltinCall::clear_convert() {
  if (call_case() == kConvert) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.call_.convert_;
    }
    clear_has_call();
  }
}
inline ::vyper::ConvertCall* BuiltinCall::release_convert() {
  // @@protoc_insertion_point(field_release:vyper.BuiltinCall.convert)
  if (call_case() == kConvert) {
    clear_has_call();
    ::vyper::ConvertCall* temp = _impl_.call_.convert_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.call_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vyper::ConvertCall& BuiltinCall::_internal_convert() const {
  return call_case() == kConvert
      ? *_impl_.call_.convert_
      : reinterpret_cast< ::vyper::ConvertCall&>(::vyper::_ConvertCall_default_instance_);
}
inline const ::vyper::ConvertCall& BuiltinCall::convert() const {
  // @@protoc_insertion_point(field_get:vyper.BuiltinCall.convert)
  return _internal_convert();
}
inline ::vyper::ConvertCall* BuiltinCall::unsafe_arena_release_convert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vyper.BuiltinCall.convert)
  if (call_case() == kConvert) {
    clear_has_call();
    ::vyper::ConvertCall* temp = _impl_.call_.convert_;
    _impl_.call_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BuiltinCall::unsafe_arena_set_allocated_convert(::vyper::ConvertCall* convert) {
  clear_call();
  if (convert) {
    set_has_convert();
    _impl_.call_.convert_ = convert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vyper.BuiltinCall.convert)
}
inline ::vyper::ConvertCall* BuiltinCall::_internal_mutable_convert() {
  if (call_case() != kConvert) {
    clear_call();
    set_has_convert();
    _impl_.call_.convert_ = CreateMaybeMessage< ::vyper::ConvertCall >(GetArenaForAllocation());
  }
  return _impl_.call_.convert_;
}
inline ::vyper::ConvertCall* BuiltinCall::mutable_convert() {
  ::vyper::ConvertCall* _msg = _internal_mutable_convert();
  // @@protoc_insertion_point(field_mutable:vyper.BuiltinCall.convert)
  return _msg;
}

inline bool BuiltinCall::has_call() const {
  return call_case() != CALL_NOT_SET;
}
inline void BuiltinCall::clear_has_call() {
  _impl_._oneof_case_[0] = CALL_NOT_SET;
}
inline BuiltinCall::CallCase BuiltinCall::call_case() const {
  return BuiltinCall::CallCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VyperContract

// repeated .vyper.FunctionDef functions = 1;
inline int VyperContract::_internal_functions_size() const {
  return _impl_.functions_.size();
}
inline int VyperContract::functions_size() const {
  return _internal_functions_size();
}
inline void VyperContract::clear_functions() {
  _impl_.functions_.Clear();
}
inline ::vyper::FunctionDef* VyperContract::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:vyper.VyperContract.functions)
  return _impl_.functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >*
VyperContract::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:vyper.VyperContract.functions)
  return &_impl_.functions_;
}
inline const ::vyper::FunctionDef& VyperContract::_internal_functions(int index) const {
  return _impl_.functions_.Get(index);
}
inline const ::vyper::FunctionDef& VyperContract::functions(int index) const {
  // @@protoc_insertion_point(field_get:vyper.VyperContract.functions)
  return _internal_functions(index);
}
inline ::vyper::FunctionDef* VyperContract::_internal_add_functions() {
  return _impl_.functions_.Add();
}
inline ::vyper::FunctionDef* VyperContract::add_functions() {
  ::vyper::FunctionDef* _add = _internal_add_functions();
  // @@protoc_insertion_point(field_add:vyper.VyperContract.functions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vyper::FunctionDef >&
VyperContract::functions() const {
  // @@protoc_insertion_point(field_list:vyper.VyperContract.functions)
  return _impl_.functions_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace vyper


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::vyper::Operator_OPERATOR> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::vyper::Operator_OPERATOR>() {
  return ::vyper::Operator_OPERATOR_descriptor();
}
template <>
struct is_proto_enum<::vyper::TYPE_ENUM> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::vyper::TYPE_ENUM>() {
  return ::vyper::TYPE_ENUM_descriptor();
}
template <>
struct is_proto_enum<::vyper::SIZED_TYPE_ENUM> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::vyper::SIZED_TYPE_ENUM>() {
  return ::vyper::SIZED_TYPE_ENUM_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_vyper_2eproto_2epb_2eh
